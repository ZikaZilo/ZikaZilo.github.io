[{"content":"Python变量的基本概念 在Python中，变量是用来存储数据的“标签”或“名字”，它指向内存中的某个对象 (◕‿◕✿)\n核心特点： 无需声明类型（动态类型语言） 通过赋值自动创建变量 变量本身没有类型，它指向的对象有类型 比如：\n1 2 3 4 x = 42 # 整数 name = \u0026#34;DeepSeek\u0026#34; # 字符串 pi = 3.14 # 浮点数 is_cool = True # 布尔值 变量的命名规则 Python变量命名需遵守以下规则 (•̀ᴗ•́)و：\n合法字符：字母、数字、下划线（但不能以数字开头）\n正确：user_name, total_count2 错误：2nd_place（数字开头）、user-name（含连字符） 区分大小写：\n1 2 age = 20 Age = 30 # 这是另一个变量！ 避免关键字：\n不能使用if、for、while等Python保留字 (╯°□°)╯︵ ┻━┻\n1 class = \u0026#34;CS101\u0026#34; # 语法错误！ 风格建议（PEP 8）：\n变量名推荐小写 + 下划线（snake_case）：student_name 常量全大写：MAX_SIZE = 100 变量赋值机制 Python的变量是对象的引用，而非存储数据的容器 (ﾉ◕ヮ◕)ﾉ*:･ﾟ✧\n示例：\n1 2 3 4 a = 10 b = a # b也指向10这个对象 a = 20 # 现在a指向新对象20，b仍指向10 print(b) # 输出：10 多重赋值：\n1 2 x, y, z = 1, \u0026#34;hello\u0026#34;, True # 同时赋值多个变量 x = y = z = 0 # 所有变量指向同一个对象 变量类型推断 虽然不需要声明类型，但对象有明确类型 (๑•̀ㅂ•́)و✧：\n1 2 3 num = 42 # \u0026lt;class \u0026#39;int\u0026#39;\u0026gt; text = \u0026#34;DeepSeek\u0026#34; # \u0026lt;class \u0026#39;str\u0026#39;\u0026gt; lst = [1, 2, 3] # \u0026lt;class \u0026#39;list\u0026#39;\u0026gt; 可以用type()函数检查类型：\n1 print(type(num)) # 输出：\u0026lt;class \u0026#39;int\u0026#39;\u0026gt; 特殊变量 删除变量：用del释放引用\n1 2 3 temp = 100 del temp # 移除变量名 print(temp) # 报错：NameError 动态类型：变量可随时指向不同类型\n1 2 stuff = 42 # 现在是int stuff = \u0026#34;答案\u0026#34; # 瞬间变成str 作用域规则 变量的“可见范围”由其定义位置决定 (ﾉ´ヮ`)ﾉ*: ･ﾟ\n局部变量：函数内定义，仅在函数内有效 全局变量：模块级定义，全局可访问（但函数内修改需声明global） 示例：\n1 2 3 4 5 6 7 8 9 10 global_var = \u0026#34;我是全局的\u0026#34; def test(): local_var = \u0026#34;我是局部的\u0026#34; print(global_var) # 可以访问全局变量 global new_var # 声明为全局变量 new_var = 100 test() print(local_var) # 报错：local_var未定义 总结 总结一下 (￣^￣)ゞ：\nPython变量是名字到对象的绑定 命名要合法且风格统一 类型灵活但需注意作用域 试着玩转变量吧～ ヾ(≧▽≦*)o\n","date":"2025-01-01T00:00:00Z","image":"//localhost:1313/p/program-python-basic-01-variable/cover_hu_857d88d6b0a3b5cd.jpeg","permalink":"//localhost:1313/p/program-python-basic-01-variable/","title":"Python Basic 01 变量定义"},{"content":"函数定义基础概念 (◕‿◕✿) 函数是Python中可复用的代码块，通过def关键字定义：\n1 2 3 4 def 函数名(参数列表): \u0026#34;\u0026#34;\u0026#34;文档字符串（可选）\u0026#34;\u0026#34;\u0026#34; 函数体 return 返回值 # 可选 命名规则：推荐使用snake_case，如calculate_average() 参数：支持位置参数、默认参数等（后面会展开讲哦~） 返回值：用return返回，若无return语句则返回None 举个栗子 🌰：\n1 2 3 4 def greet(name): \u0026#34;\u0026#34;\u0026#34;输出个性化问候\u0026#34;\u0026#34;\u0026#34; print(f\u0026#34;Hello, {name}! (ﾉ◕ヮ◕)ﾉ*:･ﾟ✧\u0026#34;) return len(name) # 返回名字长度 参数传递机制 不可变对象 vs 可变对象 不可变对象（数字/字符串/元组）：传值（副本） 1 2 3 4 def modify_num(x): x += 10 # 不影响外部变量 n = 5 modify_num(n) # n仍是5 可变对象（列表/字典）：传引用（原地修改） 1 2 3 4 def append_item(lst): lst.append(\u0026#34;🎉\u0026#34;) my_list = [1, 2] append_item(my_list) # my_list变为[1, 2, \u0026#34;🎉\u0026#34;] 参数类型大全 参数类型 语法示例 说明 位置参数 func(a, b) 按顺序传参 关键字参数 func(b=2, a=1) 指定参数名传参 默认参数 def func(a=0) 参数默认值 可变位置参数 def func(*args) 接收元组 args=(1,2,3) 可变关键字参数 def func(**kwargs) 接收字典 kwargs={\u0026quot;x\u0026quot;:1} 举个混合参数的例子 🌈：\n1 2 3 4 5 def mixed_params(a, b=2, *args, **kwargs): print(f\u0026#34;a={a}, b={b}, args={args}, kwargs={kwargs}\u0026#34;) mixed_params(1, 3, 4, 5, key=\u0026#34;value\u0026#34;) # 输出: a=1, b=3, args=(4, 5), kwargs={\u0026#39;key\u0026#39;: \u0026#39;value\u0026#39;} 高阶函数特性 函数作为对象 函数是一等公民，可以被赋值/传递 (•̀ᴗ•́)و\n1 2 3 4 5 def square(x): return x ** 2 func_obj = square # 函数赋值 print(func_obj(3)) # 输出9 嵌套函数与闭包 嵌套函数：函数内部定义函数 1 2 3 4 def outer(): def inner(): print(\u0026#34;我是套娃函数！(≧∇≦)ﾉ\u0026#34;) return inner() 闭包：携带外部作用域的变量 1 2 3 4 5 6 7 def power_factory(exp): def power(base): return base ** exp # 记住exp的值 return power square = power_factory(2) # 专用平方函数 print(square(3)) # 输出9 装饰器（核心知识点！✨） 装饰器本质是高阶函数，用于增强函数功能：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 def debug_decorator(func): def wrapper(*args, **kwargs): print(f\u0026#34;⚡️ 调用 {func.__name__}()\u0026#34;) return func(*args, **kwargs) return wrapper @debug_decorator # 语法糖 def say_hello(): print(\u0026#34;Hello World!\u0026#34;) say_hello() # 输出: # ⚡️ 调用 say_hello() # Hello World! 函数注解（Type Hints） Python 3.5+ 支持类型提示，用-\u0026gt;指定返回类型：\n1 2 3 def add(a: int, b: int) -\u0026gt; int: \u0026#34;\u0026#34;\u0026#34;两数相加\u0026#34;\u0026#34;\u0026#34; return a + b 优点：提升代码可读性，IDE能智能提示 注意：不会强制类型检查（需配合mypy等工具） 希望这份指南能帮你掌握Python函数精髓！(๑•̀ㅂ•́)و✧ 有疑问随时提问~\n","date":"2025-01-01T00:00:00Z","image":"//localhost:1313/p/program-python-basic-02-function/prog-python-02-function-cover_hu_857d88d6b0a3b5cd.jpeg","permalink":"//localhost:1313/p/program-python-basic-02-function/","title":"Python Basic 02 函数定义"},{"content":"Python分支结构概述 (๑•̀ㅂ•́)و✧ Python中的分支结构主要通过条件语句实现，它能让程序根据不同的条件选择性地执行代码块。在Python中，主要使用if、elif和else关键字来构建分支逻辑，就像人生中的选择题一样，程序会根据条件判断选择不同的道路前进呢！(◕‿◕✿)\n基本分支结构 最简单的if语句 1 2 if 条件表达式: # 条件为True时执行的代码块 示例：\n1 2 3 x = 10 if x \u0026gt; 5: print(\u0026#34;x大于5呢！\u0026#34;) # 这个会被执行 ╰(*°▽°*)╯ if-else结构 当需要处理两种情况时：\n1 2 3 4 if 条件表达式: # 条件为True时执行的代码 else: # 条件为False时执行的代码 示例：\n1 2 3 4 5 age = 17 if age \u0026gt;= 18: print(\u0026#34;成年啦！可以进入~\u0026#34;) else: print(\u0026#34;抱歉，未成年不能进入哦 (；′⌒`)\u0026#34;) if-elif-else结构 当有多种可能性时：\n1 2 3 4 5 6 7 if 条件1: # 满足条件1时执行 elif 条件2: # 满足条件2时执行 ... else: # 其他情况执行 示例：\n1 2 3 4 5 6 7 8 9 score = 85 if score \u0026gt;= 90: print(\u0026#34;优秀！٩(๑❛ᴗ❛๑)۶\u0026#34;) elif score \u0026gt;= 75: print(\u0026#34;良好~ (￣▽￣)~*\u0026#34;) elif score \u0026gt;= 60: print(\u0026#34;及格... 再接再厉！\u0026#34;) else: print(\u0026#34;不及格啊啊啊 (ﾟДﾟ*)ﾉ\u0026#34;) 嵌套分支结构 有时候需要在条件分支中再嵌套条件判断：\n1 2 3 4 5 6 7 if 外层条件: if 内层条件: # 代码块 else: # 代码块 else: # 代码块 示例：\n1 2 3 4 5 6 7 8 9 num = 15 if num \u0026gt; 10: print(\u0026#34;大于10\u0026#34;) if num % 2 == 0: print(\u0026#34;而且是偶数呢！\u0026#34;) else: print(\u0026#34;但是是奇数哟~\u0026#34;) else: print(\u0026#34;不大于10 (╯︵╰,)\u0026#34;) 条件表达式 在Python中可以使用条件表达式（类似其他语言的三目运算符）：\n1 值1 if 条件 else 值2 示例：\n1 2 3 x = 10 y = 20 max_val = x if x \u0026gt; y else y # 获取较大值 布尔运算与分支 可以使用逻辑运算符组合多个条件：\nand：与 or：或 not：非 示例：\n1 2 3 4 age = 22 height = 175 if age \u0026gt;= 18 and height \u0026gt;= 170: print(\u0026#34;符合参军条件！(•̀ᴗ•́)و\u0026#34;) 特殊值判断 在Python中，一些特殊值会被视为False：\nFalse None 数值0 空序列：\u0026quot;\u0026quot;、[]、() 空映射：{} 可以利用这个特性简化判断：\n1 2 3 name = \u0026#34;\u0026#34; if not name: print(\u0026#34;名字为空哦！(⊙ˍ⊙)\u0026#34;) 使用技巧与小贴士 代码风格：Python依赖缩进，一定要保持一致的缩进（通常4个空格） 执行效率：条件判断会从上到下依次执行，将最可能满足的条件放在前面可以提高效率 比较运算符： ==：等于 !=：不等于 \u0026gt;、\u0026lt;、\u0026gt;=、\u0026lt;=：大小比较 is：判断对象是否相同（比较内存地址） in：判断元素是否在序列中 示例：\n1 2 3 colors = [\u0026#34;red\u0026#34;, \u0026#34;green\u0026#34;, \u0026#34;blue\u0026#34;] if \u0026#34;green\u0026#34; in colors: print(\u0026#34;找到绿色啦！(★ω★)\u0026#34;) 实际应用小案例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 # 简单的计算器 print(\u0026#34;简易计算器启动~ (=´ω｀=)\u0026#34;) num1 = float(input(\u0026#34;请输入第一个数字：\u0026#34;)) operator = input(\u0026#34;请输入运算符(+ - * /)：\u0026#34;) num2 = float(input(\u0026#34;请输入第二个数字：\u0026#34;)) if operator == \u0026#34;+\u0026#34;: result = num1 + num2 elif operator == \u0026#34;-\u0026#34;: result = num1 - num2 elif operator == \u0026#34;*\u0026#34;: result = num1 * num2 elif operator == \u0026#34;/\u0026#34;: if num2 != 0: result = num1 / num2 else: result = \u0026#34;错误：除数不能为0！(╯‵□′)╯︵┻━┻\u0026#34; else: result = \u0026#34;错误：无效的运算符！Σ( ° △ °|||)︴\u0026#34; print(f\u0026#34;计算结果：{result}\u0026#34;) 分支结构是Python编程的基础呢！熟练掌握它们可以让你的程序更加\u0026quot;聪明\u0026quot;和灵活 (๑•̀ㅂ•́)و✧ 记住多多练习不同的分支场景，遇到问题随时问我哦~ (づ￣3￣)づ╭❤～\n","date":"2025-01-01T00:00:00Z","image":"//localhost:1313/p/program-python-basic-03-if/prog-python-03-if-cover_hu_857d88d6b0a3b5cd.jpeg","permalink":"//localhost:1313/p/program-python-basic-03-if/","title":"Python Basic 03 分支语句"},{"content":"循环的基本概念 在编程中，循环(Loop) 是重复执行某段代码的控制结构。主要有两种类型：\n确定循环：明确知道循环次数 (如for循环) 不确定循环：根据条件判断是否继续循环 (如while循环) 循环结构是我们处理重复性工作的利器呢 (ง •_•)ง\nfor循环详解 基本语法 1 2 for 临时变量 in 可迭代对象: # 循环体 这里的可迭代对象可以是：\n序列类型：字符串、列表、元组 字典(遍历键) range对象 文件对象等 range函数使用 生成整数序列的神器 ✨\n1 2 3 range(stop) # 0到stop-1 range(start, stop) # start到stop-1 range(start, stop, step) # 自定义步长 经典应用场景 1 2 3 4 5 # 计算1到100的和 (๑•̀ㅂ•́)و✧ total = 0 for num in range(1, 101): total += num print(f\u0026#34;1到100的和是: {total}\u0026#34;) while循环深入 基本语法 1 2 while 条件表达式: # 循环体 注意事项 ⚠️ 一定要确保循环条件最终能变为False，否则会进入无限循环！\n1 2 3 4 5 # 安全示例 count = 0 while count \u0026lt; 5: print(f\u0026#34;当前计数: {count}\u0026#34;) count += 1 # 千万别忘了这行！(ノಠ益ಠ)ノ 循环控制语句 break语句 立即终止当前循环 (╯°□°)╯\n1 2 3 4 for num in range(10): if num == 5: break print(num) # 只打印0-4 continue语句 跳过当前迭代，进入下一次 (￣▽￣*)ゞ\n1 2 3 4 for num in range(10): if num % 2 == 0: continue print(num) # 只打印奇数 else子句 循环正常结束(非break终止)时执行 (。-`ω´-)\n1 2 3 4 for num in range(3): print(num) else: print(\u0026#34;循环正常结束啦~\u0026#34;) 嵌套循环 循环套循环，解决多维问题 ヽ(✿ﾟ▽ﾟ)ノ\n1 2 3 4 5 # 打印九九乘法表 for i in range(1, 10): for j in range(1, i+1): print(f\u0026#34;{j}×{i}={i*j}\u0026#34;, end=\u0026#34;\\t\u0026#34;) print() # 换行 循环优化技巧 列表推导式 简洁优雅的循环替代方案 ✨\n1 squares = [x**2 for x in range(10)] # 生成平方数列表 使用enumerate 同时获取索引和值 (￣ω￣)\n1 2 3 fruits = [\u0026#39;apple\u0026#39;, \u0026#39;banana\u0026#39;, \u0026#39;cherry\u0026#39;] for index, fruit in enumerate(fruits): print(f\u0026#34;索引 {index} 是 {fruit}\u0026#34;) 使用zip 并行迭代多个序列 ٩(◕‿◕｡)۶\n1 2 3 4 names = [\u0026#39;Alice\u0026#39;, \u0026#39;Bob\u0026#39;, \u0026#39;Charlie\u0026#39;] ages = [24, 30, 22] for name, age in zip(names, ages): print(f\u0026#34;{name} is {age} years old\u0026#34;) 性能考量 在科研计算中，循环性能很重要哦！(｀・ω・´)\n避免在循环内做重复计算 对于大数据处理，考虑使用NumPy的矢量化操作 必要时使用内置函数(map, filter等)替代显式循环 ","date":"2025-01-01T00:00:00Z","image":"//localhost:1313/p/program-python-basic-04-for/prog-python-04-for-cover_hu_857d88d6b0a3b5cd.jpeg","permalink":"//localhost:1313/p/program-python-basic-04-for/","title":"Python Basic 04 循环语句"},{"content":"创建字符串 (★ω★) 1 2 3 4 5 6 # 三种引号创建字符串 str1 = \u0026#39;单引号字符串\u0026#39; str2 = \u0026#34;双引号字符串\u0026#34; str3 = \u0026#39;\u0026#39;\u0026#39;三引号可以 跨行 的字符串\u0026#39;\u0026#39;\u0026#39; 基础操作 (*￣▽￣)b 1 2 3 4 5 6 7 8 9 10 11 12 13 s = \u0026#34;Hello Python\u0026#34; # 字符串长度 len(s) # 12 # 索引访问 s[0] # \u0026#39;H\u0026#39; (第一个字符) s[-1] # \u0026#39;n\u0026#39; (最后一个字符)s # 切片操作 s[0:5] # \u0026#39;Hello\u0026#39; (第0到4个字符) s[6:] # \u0026#39;Python\u0026#39; (第6个到末尾) s[::2] # \u0026#39;HloPto\u0026#39; (每隔一个字符) 字符串常用方法 ヾ(^▽^*))) 修改字符串 1 2 3 4 5 6 7 8 9 10 11 12 13 # 转换大小写 \u0026#34;hello\u0026#34;.upper() # \u0026#39;HELLO\u0026#39; \u0026#34;HELLO\u0026#34;.lower() # \u0026#39;hello\u0026#39; \u0026#34;hello world\u0026#34;.title() # \u0026#39;Hello World\u0026#39; \u0026#34;hello world\u0026#34;.capitalize() # \u0026#39;Hello world\u0026#39; # 替换 \u0026#34;hello\u0026#34;.replace(\u0026#39;l\u0026#39;, \u0026#39;L\u0026#39;) # \u0026#39;heLLo\u0026#39; # 去除空白 \u0026#34; hello \u0026#34;.strip() # \u0026#39;hello\u0026#39; \u0026#34; hello \u0026#34;.lstrip() # \u0026#39;hello \u0026#39; \u0026#34; hello \u0026#34;.rstrip() # \u0026#39; hello\u0026#39; 拼接与分割 (ﾉ◕ヮ◕)ﾉ*:･ﾟ✧ 1 2 3 4 5 6 7 8 # 拼接 \u0026#34;, \u0026#34;.join([\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;orange\u0026#34;]) # \u0026#39;apple, banana, orange\u0026#39; # 分割 \u0026#34;apple,banana,orange\u0026#34;.split(\u0026#34;,\u0026#34;) # [\u0026#39;apple\u0026#39;, \u0026#39;banana\u0026#39;, \u0026#39;orange\u0026#39;] # 按行分割 \u0026#34;line1\\nline2\\nline3\u0026#34;.splitlines() # [\u0026#39;line1\u0026#39;, \u0026#39;line2\u0026#39;, \u0026#39;line3\u0026#39;] 查找与判断 (=￣ω￣=) 1 2 3 4 5 6 7 8 9 10 11 # 查找位置 \u0026#34;hello\u0026#34;.find(\u0026#39;l\u0026#39;) # 2 (第一个\u0026#39;l\u0026#39;的位置) \u0026#34;hello\u0026#34;.rfind(\u0026#39;l\u0026#39;) # 3 (最后一个\u0026#39;l\u0026#39;的位置) \u0026#34;hello\u0026#34;.index(\u0026#39;e\u0026#39;) # 1 (类似于find但如果找不到会报错) # 判断内容 \u0026#34;123\u0026#34;.isdigit() # True (全是数字) \u0026#34;abc\u0026#34;.isalpha() # True (全是字母) \u0026#34;abc123\u0026#34;.isalnum() # True (字母或数字) \u0026#34;hello\u0026#34;.startswith(\u0026#39;he\u0026#39;) # True \u0026#34;hello\u0026#34;.endswith(\u0026#39;lo\u0026#39;) # True 格式化字符串 (｀・ω・´) 1 2 3 4 5 6 7 8 9 10 11 12 # 1. % 格式化 (老方法) \u0026#34;Hello, %s!\u0026#34; % \u0026#34;World\u0026#34; # \u0026#39;Hello, World!\u0026#39; \u0026#34;%d + %d = %d\u0026#34; % (1, 2, 1+2) # \u0026#39;1 + 2 = 3\u0026#39; # 2. format方法 \u0026#34;Hello, {}!\u0026#34;.format(\u0026#34;World\u0026#34;) # \u0026#39;Hello, World!\u0026#39; \u0026#34;{1} {0} {1}\u0026#34;.format(\u0026#34;world\u0026#34;, \u0026#34;hello\u0026#34;) # \u0026#39;hello world hello\u0026#39; # 3. f-string (Python 3.6+) name = \u0026#34;Alice\u0026#34; age = 25 f\u0026#34;My name is {name} and I\u0026#39;m {age} years old.\u0026#34; 转义字符 (⊙ˍ⊙) 1 2 3 4 print(\u0026#34;换行\\n制表符\\t双引号\\\u0026#34;单引号\\\u0026#39;反斜杠\\\\\u0026#34;) # 输出: # 换行 # 制表符 双引号\u0026#34;单引号\u0026#39;反斜杠\\ 其他有用操作 ٩(◕‿◕｡)۶ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 # 字符串重复 \u0026#34;Hi\u0026#34; * 3 # \u0026#39;HiHiHi\u0026#39; # 对齐 \u0026#34;hello\u0026#34;.ljust(10) # \u0026#39;hello \u0026#39; \u0026#34;hello\u0026#34;.rjust(10) # \u0026#39; hello\u0026#39; \u0026#34;hello\u0026#34;.center(10) # \u0026#39; hello \u0026#39; # 计数 \u0026#34;hello hello\u0026#34;.count(\u0026#39;l\u0026#39;) # 4 (统计\u0026#39;l\u0026#39;出现的次数) # 判断空白字符 \u0026#34; \u0026#34;.isspace() # True # 反转字符串 s = \u0026#34;Python\u0026#34; s[::-1] # \u0026#39;nohtyP\u0026#39; # 多条件分割 import re re.split(r\u0026#39;[,;|\\s]\\s*\u0026#39;, \u0026#34;one,two;three|four five\u0026#34;) # [\u0026#39;one\u0026#39;, \u0026#39;two\u0026#39;, \u0026#39;three\u0026#39;, \u0026#39;four\u0026#39;, \u0026#39;five\u0026#39;] 总结 字符串操作真的是Python编程中最常用的技能之一呢！(ﾉ≧∀≦)ﾉ 多加练习才能熟练掌握哦！(•̀ᴗ•́)و ̑̑\n","date":"2025-01-01T00:00:00Z","image":"//localhost:1313/p/program-python-basic-05-string/prog-python-05-string_hu_857d88d6b0a3b5cd.jpeg","permalink":"//localhost:1313/p/program-python-basic-05-string/","title":"Python Basic 05 字符串处理"},{"content":"创建字符串 (★ω★) 1 2 3 4 5 6 # 三种引号创建字符串 str1 = \u0026#39;单引号字符串\u0026#39; str2 = \u0026#34;双引号字符串\u0026#34; str3 = \u0026#39;\u0026#39;\u0026#39;三引号可以 跨行 的字符串\u0026#39;\u0026#39;\u0026#39; 基础操作 (*￣▽￣)b 1 2 3 4 5 6 7 8 9 10 11 12 13 s = \u0026#34;Hello Python\u0026#34; # 字符串长度 len(s) # 12 # 索引访问 s[0] # \u0026#39;H\u0026#39; (第一个字符) s[-1] # \u0026#39;n\u0026#39; (最后一个字符)s # 切片操作 s[0:5] # \u0026#39;Hello\u0026#39; (第0到4个字符) s[6:] # \u0026#39;Python\u0026#39; (第6个到末尾) s[::2] # \u0026#39;HloPto\u0026#39; (每隔一个字符) 字符串常用方法 ヾ(^▽^*))) 修改字符串 1 2 3 4 5 6 7 8 9 10 11 12 13 # 转换大小写 \u0026#34;hello\u0026#34;.upper() # \u0026#39;HELLO\u0026#39; \u0026#34;HELLO\u0026#34;.lower() # \u0026#39;hello\u0026#39; \u0026#34;hello world\u0026#34;.title() # \u0026#39;Hello World\u0026#39; \u0026#34;hello world\u0026#34;.capitalize() # \u0026#39;Hello world\u0026#39; # 替换 \u0026#34;hello\u0026#34;.replace(\u0026#39;l\u0026#39;, \u0026#39;L\u0026#39;) # \u0026#39;heLLo\u0026#39; # 去除空白 \u0026#34; hello \u0026#34;.strip() # \u0026#39;hello\u0026#39; \u0026#34; hello \u0026#34;.lstrip() # \u0026#39;hello \u0026#39; \u0026#34; hello \u0026#34;.rstrip() # \u0026#39; hello\u0026#39; 拼接与分割 (ﾉ◕ヮ◕)ﾉ*:･ﾟ✧ 1 2 3 4 5 6 7 8 # 拼接 \u0026#34;, \u0026#34;.join([\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;orange\u0026#34;]) # \u0026#39;apple, banana, orange\u0026#39; # 分割 \u0026#34;apple,banana,orange\u0026#34;.split(\u0026#34;,\u0026#34;) # [\u0026#39;apple\u0026#39;, \u0026#39;banana\u0026#39;, \u0026#39;orange\u0026#39;] # 按行分割 \u0026#34;line1\\nline2\\nline3\u0026#34;.splitlines() # [\u0026#39;line1\u0026#39;, \u0026#39;line2\u0026#39;, \u0026#39;line3\u0026#39;] 查找与判断 (=￣ω￣=) 1 2 3 4 5 6 7 8 9 10 11 # 查找位置 \u0026#34;hello\u0026#34;.find(\u0026#39;l\u0026#39;) # 2 (第一个\u0026#39;l\u0026#39;的位置) \u0026#34;hello\u0026#34;.rfind(\u0026#39;l\u0026#39;) # 3 (最后一个\u0026#39;l\u0026#39;的位置) \u0026#34;hello\u0026#34;.index(\u0026#39;e\u0026#39;) # 1 (类似于find但如果找不到会报错) # 判断内容 \u0026#34;123\u0026#34;.isdigit() # True (全是数字) \u0026#34;abc\u0026#34;.isalpha() # True (全是字母) \u0026#34;abc123\u0026#34;.isalnum() # True (字母或数字) \u0026#34;hello\u0026#34;.startswith(\u0026#39;he\u0026#39;) # True \u0026#34;hello\u0026#34;.endswith(\u0026#39;lo\u0026#39;) # True 格式化字符串 (｀・ω・´) 1 2 3 4 5 6 7 8 9 10 11 12 # 1. % 格式化 (老方法) \u0026#34;Hello, %s!\u0026#34; % \u0026#34;World\u0026#34; # \u0026#39;Hello, World!\u0026#39; \u0026#34;%d + %d = %d\u0026#34; % (1, 2, 1+2) # \u0026#39;1 + 2 = 3\u0026#39; # 2. format方法 \u0026#34;Hello, {}!\u0026#34;.format(\u0026#34;World\u0026#34;) # \u0026#39;Hello, World!\u0026#39; \u0026#34;{1} {0} {1}\u0026#34;.format(\u0026#34;world\u0026#34;, \u0026#34;hello\u0026#34;) # \u0026#39;hello world hello\u0026#39; # 3. f-string (Python 3.6+) name = \u0026#34;Alice\u0026#34; age = 25 f\u0026#34;My name is {name} and I\u0026#39;m {age} years old.\u0026#34; 转义字符 (⊙ˍ⊙) 1 2 3 4 print(\u0026#34;换行\\n制表符\\t双引号\\\u0026#34;单引号\\\u0026#39;反斜杠\\\\\u0026#34;) # 输出: # 换行 # 制表符 双引号\u0026#34;单引号\u0026#39;反斜杠\\ 其他有用操作 ٩(◕‿◕｡)۶ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 # 字符串重复 \u0026#34;Hi\u0026#34; * 3 # \u0026#39;HiHiHi\u0026#39; # 对齐 \u0026#34;hello\u0026#34;.ljust(10) # \u0026#39;hello \u0026#39; \u0026#34;hello\u0026#34;.rjust(10) # \u0026#39; hello\u0026#39; \u0026#34;hello\u0026#34;.center(10) # \u0026#39; hello \u0026#39; # 计数 \u0026#34;hello hello\u0026#34;.count(\u0026#39;l\u0026#39;) # 4 (统计\u0026#39;l\u0026#39;出现的次数) # 判断空白字符 \u0026#34; \u0026#34;.isspace() # True # 反转字符串 s = \u0026#34;Python\u0026#34; s[::-1] # \u0026#39;nohtyP\u0026#39; # 多条件分割 import re re.split(r\u0026#39;[,;|\\s]\\s*\u0026#39;, \u0026#34;one,two;three|four five\u0026#34;) # [\u0026#39;one\u0026#39;, \u0026#39;two\u0026#39;, \u0026#39;three\u0026#39;, \u0026#39;four\u0026#39;, \u0026#39;five\u0026#39;] 总结 字符串操作真的是Python编程中最常用的技能之一呢！(ﾉ≧∀≦)ﾉ 多加练习才能熟练掌握哦！(•̀ᴗ•́)و ̑̑\n","date":"2025-01-01T00:00:00Z","image":"//localhost:1313/p/program-python-basic-06-list/prog-python-06-list_hu_857d88d6b0a3b5cd.jpeg","permalink":"//localhost:1313/p/program-python-basic-06-list/","title":"Python Basic 06 列表处理"},{"content":"标准输出 - print() 最常用的输出函数，默认输出到控制台(￣▽￣*)\n1 2 3 print(\u0026#34;Hello World!\u0026#34;) # 输出字符串 print(42) # 输出数字 print([1, 2, 3]) # 输出列表 格式化输出方式：\n1 2 3 4 5 6 7 name = \u0026#34;Alice\u0026#34; age = 25 # f-string (Python 3.6+推荐) print(f\u0026#34;{name} is {age} years old!\u0026#34;) # format方法 print(\u0026#34;{} is {} years old!\u0026#34;.format(name, age)) 标准输入 - input() 从命令行获取用户输入(๑•̀ㅂ•́)و✧\n基础用法：\n1 2 name = input(\u0026#34;请输入你的名字: \u0026#34;) # 提示语是可选的 print(f\u0026#34;你好，{name}!\u0026#34;) ⚠️ 注意：\ninput()永远返回字符串类型 需要其他类型要用类型转换： 1 age = int(input(\u0026#34;请输入年龄: \u0026#34;)) # 转换为整数 命令行参数 - sys.argv 程序启动时传递的参数可以通过sys模块获取(ﾉ◕ヮ◕)ﾉ*:･ﾟ✧\n1 2 3 4 import sys print(\u0026#34;脚本名:\u0026#34;, sys.argv[0]) # 第一个参数总是脚本名称 print(\u0026#34;参数列表:\u0026#34;, sys.argv[1:]) # 后续是传递的参数 运行示例：\n1 python script.py arg1 arg2 文件描述符操作 更底层的方式是直接操作文件描述符(ง •_•)ง\n1 2 3 4 5 6 7 import sys # 标准错误输出 sys.stderr.write(\u0026#34;这是一个错误消息\\n\u0026#34;) # 标准输入读取(一行) line = sys.stdin.readline() 高级技巧 - 重定向 可以临时重定向标准输入输出٩(◕‿◕｡)۶\n1 2 3 4 5 6 7 import sys with open(\u0026#39;output.txt\u0026#39;, \u0026#39;w\u0026#39;) as f: sys.stdout = f # 重定向标准输出 print(\u0026#34;这会被写入文件\u0026#34;) sys.stdout = sys.__stdout__ # 恢复默认 最佳实践小贴士 用户输入要始终验证： 1 2 3 4 5 6 while True: try: num = int(input(\u0026#34;请输入数字: \u0026#34;)) break except ValueError: print(\u0026#34;输入无效，请重试！\u0026#34;) 大量输出时考虑缓冲： 1 2 import sys sys.stdout.flush() # 手动刷新缓冲区 跨平台换行符： 1 print(\u0026#34;line1\u0026#34;, \u0026#34;line2\u0026#34;, sep=os.linesep) # 自动适应系统换行符 这些就是Python命令行I/O的基础知识啦！(≧∇≦)ﾉ 要进行更复杂的操作，还可以探索argparse模块(处理命令行参数)和logging模块(日志记录)哦~\n","date":"2025-01-01T00:00:00Z","image":"//localhost:1313/p/program-python-basic-06-list/prog-python-07_hu_857d88d6b0a3b5cd.jpeg","permalink":"//localhost:1313/p/program-python-basic-07/","title":"Python Basic 07 命令行IO"},{"content":"文件操作基础原理 1 文件操作 = open(文件路径, 模式) + 操作 + close() 关键概念：\n文件指针：像个书签📖记录当前读写位置 缓冲区：内存中的临时存储区（像快递中转站🚚） 编码问题：建议统一使用utf-8避免乱码 文件打开模式大全 模式 符号 说明 读模式 'r' 默认模式 (✧ω✧) 写模式 'w' 清空写入（小心数据丢失！⚠️） 追加模式 'a' 尾巴追加（安全第一☝️） 二进制模式 'b' 处理图片/视频等非文本 读写模式 '+' 组合使用如'r+' 标准读写操作 1 2 3 4 5 6 7 8 # 经典写法 with open(\u0026#39;data.txt\u0026#39;, \u0026#39;r\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as f: content = f.read() # 全部读取 lines = f.readlines() # 按行读取列表 with open(\u0026#39;output.txt\u0026#39;, \u0026#39;w\u0026#39;) as f: f.write(\u0026#34;Hello World!\\n\u0026#34;) # 写入字符串 f.writelines([\u0026#34;line1\\n\u0026#34;, \u0026#34;line2\\n\u0026#34;]) # 写入多行 🌟 最佳实践：\n永远使用with语句（自动关文件不怕漏） 大文件用迭代器逐行读取： 1 2 for line in open(\u0026#39;bigfile.txt\u0026#39;): process(line) # 内存友好~(￣▽￣)~* 高级技巧放送 🚀 1. JSON文件处理\n1 2 3 4 5 6 7 import json # 写入 with open(\u0026#39;data.json\u0026#39;, \u0026#39;w\u0026#39;) as f: json.dump({\u0026#39;key\u0026#39;: \u0026#39;value\u0026#39;}, f) # 读取 with open(\u0026#39;data.json\u0026#39;) as f: data = json.load(f) # 自动转字典 2. CSV文件处理\n1 2 3 4 5 import csv with open(\u0026#39;data.csv\u0026#39;, newline=\u0026#39;\u0026#39;) as csvfile: reader = csv.DictReader(csvfile) for row in reader: print(row[\u0026#39;name\u0026#39;], row[\u0026#39;age\u0026#39;]) 3. 二进制文件处理\n1 2 3 # 复制图片文件 with open(\u0026#39;input.jpg\u0026#39;, \u0026#39;rb\u0026#39;) as src, open(\u0026#39;output.jpg\u0026#39;, \u0026#39;wb\u0026#39;) as dst: dst.write(src.read()) # 注意内存占用哦(⊙_⊙) 常见坑点预警 ⚠️ 路径问题：\n推荐使用pathlib模块： 1 2 from pathlib import Path file_path = Path(\u0026#39;data\u0026#39;) / \u0026#39;test.txt\u0026#39; # 自动适应不同操作系统 编码问题：\n遇到编码错误时： 1 2 3 4 try: content = open(\u0026#39;file.txt\u0026#39;).read() except UnicodeDecodeError: content = open(\u0026#39;file.txt\u0026#39;, encoding=\u0026#39;gbk\u0026#39;).read() 大文件处理：\n使用chunk分块读取： 1 2 3 chunk_size = 1024 while chunk := f.read(chunk_size): process(chunk) 总结 Checklist ✅ 掌握基础读写操作 理解不同模式区别 学会with上下文管理 熟悉常用格式(JSON/CSV) 注意路径和编码问题 现在去试试这些技能吧！遇到问题随时来问~ (ง •_•)ง\n","date":"2025-01-01T00:00:00Z","image":"//localhost:1313/p/program-python-basic-08/prog-python-basic-08_hu_857d88d6b0a3b5cd.jpeg","permalink":"//localhost:1313/p/program-python-basic-08/","title":"Python Basic 08 本地文件IO"},{"content":"ini文件是一种常见的配置文件格式，Python提供了标准库configparser来轻松读写ini文件。下面我们来详细了解一下如何使用Python操作ini文件~\n基本结构速览 一个典型的ini文件长这样：\n1 2 3 4 5 6 7 [Section1] key1 = value1 key2 = value2 [Section2] keyA = valueA keyB = valueB 基础操作四连 🔸 读取ini文件 1 2 3 4 5 6 7 8 9 10 11 12 13 import configparser config = configparser.ConfigParser() config.read(\u0026#39;config.ini\u0026#39;) # (๑•̀ㅂ•́)و✧ 读取成功！ # 获取所有section sections = config.sections() # [\u0026#39;Section1\u0026#39;, \u0026#39;Section2\u0026#39;] # 获取某个section下的所有option options = config.options(\u0026#39;Section1\u0026#39;) # [\u0026#39;key1\u0026#39;, \u0026#39;key2\u0026#39;] # 获取具体值 value = config.get(\u0026#39;Section1\u0026#39;, \u0026#39;key1\u0026#39;) # \u0026#39;value1\u0026#39; 🔸 写入ini文件 1 2 3 4 5 6 7 8 9 10 11 config = configparser.ConfigParser() # 添加section和值 config[\u0026#39;DEFAULT\u0026#39;] = {\u0026#39;ServerAliveInterval\u0026#39;: \u0026#39;45\u0026#39;} config[\u0026#39;SectionA\u0026#39;] = {} config[\u0026#39;SectionA\u0026#39;][\u0026#39;User\u0026#39;] = \u0026#39;Alice\u0026#39; config[\u0026#39;SectionA\u0026#39;][\u0026#39;Age\u0026#39;] = \u0026#39;25\u0026#39; # 注意：所有值都会被转换为字符串 # 写入文件 with open(\u0026#39;new_config.ini\u0026#39;, \u0026#39;w\u0026#39;) as f: config.write(f) # ୧(﹒︠ᴗ﹒︡)୨ 保存成功！ 🔸 修改配置 1 2 3 config.set(\u0026#39;SectionA\u0026#39;, \u0026#39;Age\u0026#39;, \u0026#39;26\u0026#39;) # 修改Age的值 config.add_section(\u0026#39;NewSection\u0026#39;) # 添加新section config.remove_option(\u0026#39;SectionA\u0026#39;, \u0026#39;User\u0026#39;) # 删除选项 🔸 类型转换 1 2 3 4 # 自动转换为相应类型 is_alive = config.getboolean(\u0026#39;DEFAULT\u0026#39;, \u0026#39;ServerAliveInterval\u0026#39;) port = config.getint(\u0026#39;SectionA\u0026#39;, \u0026#39;Port\u0026#39;) ratio = config.getfloat(\u0026#39;SectionA\u0026#39;, \u0026#39;Ratio\u0026#39;) 高级技巧五连击 💡 默认值处理 1 2 # 当键不存在时返回默认值 value = config.get(\u0026#39;Section1\u0026#39;, \u0026#39;nonexist_key\u0026#39;, fallback=\u0026#39;default_value\u0026#39;) 💡 检查存在性 1 2 3 4 5 if \u0026#39;Section1\u0026#39; in config: print(\u0026#34;Section1存在！(ﾉ◕ヮ◕)ﾉ*:･ﾟ✧\u0026#34;) if config.has_option(\u0026#39;Section1\u0026#39;, \u0026#39;key1\u0026#39;): print(\u0026#34;key1存在！\u0026#34;) 💡 字典式访问 1 2 3 4 5 # 像字典一样操作 for section in config: print(f\u0026#34;[{section}]\u0026#34;) for key in config[section]: print(f\u0026#34;{key} = {config[section][key]}\u0026#34;) 💡 插值处理 1 2 3 4 5 6 7 config[\u0026#39;Paths\u0026#39;] = { \u0026#39;home_dir\u0026#39;: \u0026#39;/Users\u0026#39;, \u0026#39;my_dir\u0026#39;: \u0026#39;%(home_dir)s/Alice\u0026#39;, # 会解析为 /Users/Alice \u0026#39;my_pictures\u0026#39;: \u0026#39;%(my_dir)s/Pictures\u0026#39; } print(config[\u0026#39;Paths\u0026#39;][\u0026#39;my_pictures\u0026#39;]) # 输出: /Users/Alice/Pictures 💡 保留注释和空格（需要使用RawConfigParser） 1 2 3 4 from configparser import RawConfigParser config = RawConfigParser() config.read(\u0026#39;config_with_comments.ini\u0026#39;) # 保留原始注释内容 注意事项小贴士 ✨ 所有值都以字符串形式存储，读取时需要类型转换 ✨ DEFAULT是一个特殊section，其他section会继承它的键值 ✨ Windows路径建议使用raw字符串或双反斜杠：r'C:\\path' 或 'C:\\\\path' ✨ 大型配置文件考虑使用JSON或YAML格式 ✨ Python 3.2+推荐使用configparser，Python 2中使用ConfigParser 完整示例 下面是一个完整的操作示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 import configparser # 创建配置 config = configparser.ConfigParser() config[\u0026#39;DEFAULT\u0026#39;] = { \u0026#39;debug\u0026#39;: \u0026#39;True\u0026#39;, \u0026#39;log_level\u0026#39;: \u0026#39;INFO\u0026#39; } config[\u0026#39;database\u0026#39;] = { \u0026#39;host\u0026#39;: \u0026#39;localhost\u0026#39;, \u0026#39;port\u0026#39;: \u0026#39;5432\u0026#39;, \u0026#39;name\u0026#39;: \u0026#39;mydb\u0026#39; } # 保存配置 with open(\u0026#39;app_config.ini\u0026#39;, \u0026#39;w\u0026#39;) as f: config.write(f) # 读取配置 new_config = configparser.ConfigParser() new_config.read(\u0026#39;app_config.ini\u0026#39;) # 使用配置 debug_mode = new_config.getboolean(\u0026#39;DEFAULT\u0026#39;, \u0026#39;debug\u0026#39;) db_host = new_config[\u0026#39;database\u0026#39;][\u0026#39;host\u0026#39;] print(f\u0026#34;Debug模式: {debug_mode}, 数据库主机: {db_host}\u0026#34;) 🌟 总结 Python的configparser模块使ini文件操作变得简单高效。无论是小型应用配置还是系统设置，都能轻松应对。快去试试吧！(๑˃̵ᴗ˂̵)و\n小提示：需要更复杂的配置管理？可以看看PyYAML或toml模块哦~\n","date":"2025-01-01T00:00:00Z","image":"//localhost:1313/p/program-python-basic-08/prog-python-basic-09_hu_857d88d6b0a3b5cd.jpeg","permalink":"//localhost:1313/p/program-python-basic-09/","title":"Python Basic 09 配置文件 INI 操作"},{"content":"连接数据库 首先需要建立数据库连接：\n1 2 3 4 5 6 7 import sqlite3 # 连接数据库(如果不存在会自动创建) conn = sqlite3.connect(\u0026#39;example.db\u0026#39;) # (ﾉ◕ヮ◕)ﾉ*:･ﾟ✧ # 获取游标对象 cursor = conn.cursor() 创建表 使用execute()方法执行SQL语句创建表：\n1 2 3 4 5 6 cursor.execute(\u0026#39;\u0026#39;\u0026#39;CREATE TABLE IF NOT EXISTS users (id INTEGER PRIMARY KEY, name TEXT NOT NULL, age INTEGER)\u0026#39;\u0026#39;\u0026#39;) conn.commit() # 别忘记提交哦！(｀・ω・´)ゞ 插入数据 插入数据有以下几种方式：\n简单插入 1 cursor.execute(\u0026#34;INSERT INTO users (name, age) VALUES (\u0026#39;Alice\u0026#39;, 25)\u0026#34;) 参数化插入(推荐！可以防SQL注入) 1 cursor.execute(\u0026#34;INSERT INTO users (name, age) VALUES (?, ?)\u0026#34;, (\u0026#39;Bob\u0026#39;, 30)) 批量插入 1 2 users = [(\u0026#39;Charlie\u0026#39;, 45), (\u0026#39;David\u0026#39;, 29), (\u0026#39;Eve\u0026#39;, 33)] cursor.executemany(\u0026#34;INSERT INTO users (name, age) VALUES (?, ?)\u0026#34;, users) 记得提交：\n1 conn.commit() # 重要的提交要重复三遍！✧(≖ ◡ ≖✿) 查询数据 查询数据有以下几种方式：\n简单查询 1 2 cursor.execute(\u0026#34;SELECT * FROM users\u0026#34;) print(cursor.fetchall()) # 获取所有结果 ٩(◕‿◕｡)۶ 查询单条记录 1 2 cursor.execute(\u0026#34;SELECT * FROM users WHERE name=?\u0026#34;, (\u0026#39;Alice\u0026#39;,)) print(cursor.fetchone()) # 获取一条结果 带条件的查询 1 2 3 cursor.execute(\u0026#34;SELECT name, age FROM users WHERE age \u0026gt; ?\u0026#34;, (30,)) for row in cursor: print(f\u0026#34;{row[0]} 今年 {row[1]} 岁啦~\u0026#34;) # 迭代获取结果 这里是 (30,) 而不是 (30) 是因为当只有一个元素时， (30) 在 python 中表示数字，而后面有一个逗号才表示为元组\n更新数据 更新数据使用UPDATE语句：\n1 2 cursor.execute(\u0026#34;UPDATE users SET age = ? WHERE name = ?\u0026#34;, (26, \u0026#39;Alice\u0026#39;)) conn.commit() # 提交是必须的！(＞ω＜) 删除数据 删除数据使用DELETE语句：\n1 2 cursor.execute(\u0026#34;DELETE FROM users WHERE name = ?\u0026#34;, (\u0026#39;Eve\u0026#39;,)) conn.commit() # 最后再说一次，不要忘记提交！(╯°□°）╯︵ ┻━┻ 关闭连接 使用完毕后记得关闭连接：\n1 2 cursor.close() # 关闭游标 conn.close() # 关闭连接 使用with语句 (进阶技巧 ✨) Python的with语句可以让代码更简洁：\n1 2 3 4 5 with sqlite3.connect(\u0026#39;example.db\u0026#39;) as conn: cursor = conn.cursor() cursor.execute(\u0026#34;SELECT * FROM users\u0026#34;) print(cursor.fetchall()) # 不需要手动关闭，with会自动处理哦！(ノ◕ヮ◕)ノ*:･ﾟ✧ 希望这个小教程能帮到你！SQLite + Python真是开发小项目的好搭档呢～(￣▽￣)~*\n","date":"2025-01-01T00:00:00Z","image":"//localhost:1313/p/program-python-basic-09/prog-python-basic-10_hu_857d88d6b0a3b5cd.jpeg","permalink":"//localhost:1313/p/program-python-basic-10/","title":"Python Basic 10 Sqlite 基础操作"},{"content":"目录操作 💾 检查路径是否存在 1 2 import os path_exists = os.path.exists(\u0026#34;path/to/dir\u0026#34;) # (╯✧▽✧)╯ 返回布尔值 创建目录 1 2 os.mkdir(\u0026#34;new_dir\u0026#34;) # 创建单层目录 os.makedirs(\u0026#34;path/to/new/dirs\u0026#34;, exist_ok=True) # 递归创建多层目录 ♪(^∇^*) 删除目录 1 2 3 os.rmdir(\u0026#34;empty_dir\u0026#34;) # 只能删除空目录哦～ import shutil shutil.rmtree(\u0026#34;dir_with_content\u0026#34;) # 强力删除整个目录树 (ﾉ\u0026gt;ω\u0026lt;)ﾉ 文件/目录遍历 🌟 列出目录内容 1 2 files = os.listdir(\u0026#34;path\u0026#34;) # 返回文件名列表 entries = os.scandir(\u0026#34;path\u0026#34;) # 更高效的迭代器 (推荐！) 递归遍历所有文件 1 2 3 4 5 # 使用os.walk (ﾉ◕ヮ◕)ﾉ*:･ﾟ✧ for root, dirs, files in os.walk(\u0026#34;path\u0026#34;): print(f\u0026#34;当前目录: {root}\u0026#34;) print(f\u0026#34;子目录: {dirs}\u0026#34;) print(f\u0026#34;文件: {files}\u0026#34;) 文件信息获取 🔍 获取文件属性 1 2 3 stat = os.stat(\u0026#34;file.txt\u0026#34;) print(f\u0026#34;大小: {stat.st_size}字节\u0026#34;) # (´･ω･`)? print(f\u0026#34;修改时间: {stat.st_mtime}\u0026#34;) 判断文件类型 1 2 3 is_file = os.path.isfile(\u0026#34;path\u0026#34;) # 是不是文件 is_dir = os.path.isdir(\u0026#34;path\u0026#34;) # 是不是目录 is_link = os.path.islink(\u0026#34;path\u0026#34;) # 是不是链接 ٩(◕‿◕｡)۶ 路径操作 🛤️ 路径拼接 1 full_path = os.path.join(\u0026#34;dir\u0026#34;, \u0026#34;subdir\u0026#34;, \u0026#34;file.txt\u0026#34;) # 超实用！✨ 路径分解 1 2 dirname = os.path.dirname(\u0026#34;/path/to/file.txt\u0026#34;) # 获取目录部分 basename = os.path.basename(\u0026#34;/path/to/file.txt\u0026#34;) # 获取文件名部分 文件操作 📝 复制文件 1 2 shutil.copy(\u0026#34;src.txt\u0026#34;, \u0026#34;dst.txt\u0026#34;) # 普通复制 shutil.copy2(\u0026#34;src.txt\u0026#34;, \u0026#34;dst.txt\u0026#34;) # 保留元数据 ヽ(✿ﾟ▽ﾟ)ノ 移动/重命名 1 2 os.rename(\u0026#34;old.txt\u0026#34;, \u0026#34;new.txt\u0026#34;) # 重命名 shutil.move(\u0026#34;src.txt\u0026#34;, \u0026#34;dst.txt\u0026#34;) # 移动文件 删除文件 1 os.remove(\u0026#34;file.txt\u0026#34;) # 简单删除 高级操作 🚀 文件通配 1 2 import glob py_files = glob.glob(\u0026#34;*.py\u0026#34;) # 匹配所有.py文件 ✨.~(￣▽￣)~* 临时文件/目录 1 2 3 import tempfile temp_file = tempfile.NamedTemporaryFile(delete=False) # 临时文件 temp_dir = tempfile.mkdtemp() # 临时目录 ٩(｡・ω・｡)﻿و 权限修改 1 os.chmod(\u0026#34;file.txt\u0026#34;, 0o755) # 设置权限 (UNIX系统) 这些就是Python中最常用的系统文件操作啦！(๑•̀ㅂ•́)و✧ 记得处理文件时要注意：\n检查文件是否存在 处理可能的权限问题 使用try-except捕获异常 跨平台时要小心路径分隔符哦～ Happy coding! 🎉🐍\n","date":"2025-01-01T00:00:00Z","image":"//localhost:1313/p/program-python-basic-10/prog-python-basic-11_hu_857d88d6b0a3b5cd.jpeg","permalink":"//localhost:1313/p/program-python-basic-11/","title":"Python Basic 11 常用文件操作"},{"content":"为什么需要错误处理？ 在代码运行中难免会出现各种\u0026quot;翻车现场\u0026quot;🚗💥：\n用户输入了奇怪的东西 文件找不到了 网络连接断了 计算过程出错了\u0026hellip; 如果不处理这些错误，程序就会直接崩溃(╥﹏╥) 而好的错误处理能让程序优雅地应对意外~\n基本错误处理 - try/except 最基本的错误处理结构长这样：\n1 2 3 4 5 6 try: # 尝试运行的代码 risky_operation() except ErrorType: # 出错时执行的代码 handle_error() 举个栗子 🌰 1 2 3 4 5 try: age = int(input(\u0026#34;请输入您的年龄：\u0026#34;)) print(f\u0026#34;您明年就{age + 1}岁啦！\u0026#34;) except ValueError: print(\u0026#34;喂喂，年龄要输入数字啊！(╯°□°）╯︵ ┻━┻\u0026#34;) 输出：\n1 2 请输入您的年龄：abc 喂喂，年龄要输入数字啊！(╯°□°）╯︵ ┻━┻ 常见错误类型一览表 📋 错误类型 什么时候出现 举个栗子 SyntaxError 语法错误 print(\u0026quot;hello\u0026quot; 少括号 IndentationError 缩进错误 该缩进没缩进 NameError 访问未定义变量 print(never_defined_var) TypeError 类型操作不当 \u0026quot;1\u0026quot; + 2 ValueError 值不合法 int(\u0026quot;abc\u0026quot;) IndexError 索引越界 [1,2][99] KeyError 字典键不存在 {\u0026quot;a\u0026quot;:1}[\u0026quot;b\u0026quot;] AttributeError 访问不存在的属性 \u0026quot;str\u0026quot;.unknown_method() ZeroDivisionError 除数为零 1/0 FileNotFoundError 文件找不到 open(\u0026quot;ghost.txt\u0026quot;) 多重错误处理 可以捕获多种不同类型的错误：\n1 2 3 4 5 6 7 8 9 10 try: # 危险操作区 😈 result = 10 / int(input(\u0026#34;输入一个除数: \u0026#34;)) print(\u0026#34;结果是:\u0026#34;, result) except ValueError: print(\u0026#34;输入必须是一个数字啦！(╬ Ò﹏Ó)\u0026#34;) except ZeroDivisionError: print(\u0026#34;不能除以0啊兄弟！(ﾉ｀Д´)ﾉ\u0026#34;) except Exception as e: print(\u0026#34;发生了未知错误:\u0026#34;, str(e)) 完整的try-except-else-finally结构 1 2 3 4 5 6 7 8 9 10 11 try: print(\u0026#34;尝试打开文件...\u0026#34;) file = open(\u0026#34;data.txt\u0026#34;, \u0026#34;r\u0026#34;) except FileNotFoundError: print(\u0026#34;文件找不到了！Σ(°△°|||)︴\u0026#34;) else: print(\u0026#34;文件读取成功！内容如下：\u0026#34;) print(file.read()) file.close() finally: print(\u0026#34;无论如何我都会被执行~(￣▽￣)~*\u0026#34;) 主动抛出异常 - raise 我们也可以主动制造错误：\n1 2 3 4 5 6 7 8 9 def register(username): if len(username) \u0026lt; 3: raise ValueError(\u0026#34;用户名太短啦！至少3个字符 (＞﹏＜)\u0026#34;) # 其他注册逻辑... try: register(\u0026#34;ab\u0026#34;) except ValueError as e: print(\u0026#34;注册失败:\u0026#34;, str(e)) 自定义异常类 觉得内置错误不够用？可以自己造：\n1 2 3 4 5 6 7 8 9 10 class TooLazyError(Exception): \u0026#34;\u0026#34;\u0026#34;当程序员太懒时抛出\u0026#34;\u0026#34;\u0026#34; def __init__(self, laziness_level): self.laziness_level = laziness_level super().__init__(f\u0026#34;懒惰等级{laziness_level}超标了！需要咖啡续命☕\u0026#34;) try: raise TooLazyError(99) except TooLazyError as e: print(f\u0026#34;错误：{e}\u0026#34;) # 错误：懒惰等级99超标了！需要咖啡续命☕ 实际应用小贴士 💡 不要过度捕获：只捕获你预期会发生的错误\n1 2 3 4 5 6 7 8 9 10 11 # 不好 👎 try: do_something() except: pass # 这样会隐藏所有错误！ # 好的 👍 try: do_something() except ExpectedError: handle_error() 日志记录很重要：使用logging模块记录错误\n提供有用的错误信息：帮助用户理解问题\nfinally很强大：适合做清理工作（如关闭文件）\n9. 高阶技巧：上下文管理器(with语句) 超级好用的错误预防工具！\n1 2 3 4 5 6 7 8 9 10 11 # 传统方式 try: file = open(\u0026#34;data.txt\u0026#34;, \u0026#34;r\u0026#34;) content = file.read() finally: file.close() # 优雅方式 with open(\u0026#34;data.txt\u0026#34;, \u0026#34;r\u0026#34;) as file: content = file.read() # 文件会自动关闭，即使发生错误也不会泄露 总结 ✨ 使用try/except来保护可能出错的代码 明确定义你期望处理的错误类型 不要吞掉所有错误（这会隐藏bug） 合理使用else和finally 必要时自定义异常类 with语句是你的好朋友 记得：好的错误处理不是为了消灭所有错误，而是为了让程序在出错时能体面地应对！٩(◕‿◕｡)۶\n有问题欢迎随时问我哦~ (ノ^_^)ノ\n","date":"2025-01-01T00:00:00Z","image":"//localhost:1313/p/program-python-basic-11/prog-python-basic-12_hu_857d88d6b0a3b5cd.jpeg","permalink":"//localhost:1313/p/program-python-basic-12/","title":"Python Basic 12 常用错误处理"},{"content":"读取 CSV 文件 使用 csv 模块 1 2 3 4 5 6 import csv with open(\u0026#39;data.csv\u0026#39;, mode=\u0026#39;r\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as file: reader = csv.reader(file) for row in reader: print(row) # 每行是一个列表 ٩(◕‿◕｡)۶ 用 pandas 读取 (最常用！) 1 2 3 4 import pandas as pd df = pd.read_csv(\u0026#39;data.csv\u0026#39;) print(df.head()) # 显示前5行数据 ฅ^•ﻌ•^ฅ 写入 CSV 文件 基础写入 1 2 3 4 5 6 7 import csv data = [[\u0026#39;Name\u0026#39;, \u0026#39;Age\u0026#39;], [\u0026#39;Alice\u0026#39;, 25], [\u0026#39;Bob\u0026#39;, 30]] with open(\u0026#39;output.csv\u0026#39;, \u0026#39;w\u0026#39;, newline=\u0026#39;\u0026#39;) as file: writer = csv.writer(file) writer.writerows(data) # 写入多行数据 (•̀ᴗ•́)و pandas 写入 1 df.to_csv(\u0026#39;output.csv\u0026#39;, index=False) # index=False 避免写入索引列 (ง •̀_•́)ง 数据处理技巧 筛选数据 1 2 3 4 5 # 选择特定列 ages = df[\u0026#39;Age\u0026#39;] # 条件筛选 young_people = df[df[\u0026#39;Age\u0026#39;] \u0026lt; 30] # 筛选年龄小于30岁的人 ╰(*°▽°*)╯ 添加/删除列 1 2 3 4 5 # 添加列 df[\u0026#39;Senior\u0026#39;] = df[\u0026#39;Age\u0026#39;] \u0026gt; 60 # 删除列 df = df.drop(columns=[\u0026#39;Unnecessary\u0026#39;]) # 拜拜不需要的列 (╯‵□′)╯︵┻━┻ 处理缺失值 1 2 3 4 5 # 删除包含缺失值的行 df = df.dropna() # 填充缺失值 df = df.fillna(0) # 用0填充 ✨ 高级操作 合并 CSV 文件 1 2 3 4 5 6 7 8 df1 = pd.read_csv(\u0026#39;data1.csv\u0026#39;) df2 = pd.read_csv(\u0026#39;data2.csv\u0026#39;) # 垂直合并 (行数增加) merged = pd.concat([df1, df2]) # 水平合并 (列数增加) merged = pd.merge(df1, df2, on=\u0026#39;ID\u0026#39;) # 根据ID列合并 (ﾉ◕ヮ◕)ﾉ*:･ﾟ✧ 分组统计 1 2 # 按城市分组计算平均年龄 city_stats = df.groupby(\u0026#39;City\u0026#39;)[\u0026#39;Age\u0026#39;].mean() # 统计学的快乐 ┬─┬ ノ( ゜-゜ノ) 处理日期 1 2 df[\u0026#39;Date\u0026#39;] = pd.to_datetime(df[\u0026#39;Date\u0026#39;]) df[\u0026#39;Year\u0026#39;] = df[\u0026#39;Date\u0026#39;].dt.year # 提取年份部分 ٩(｡•ω•｡)و 小贴士 💡 大文件处理：使用 chunksize 参数分块读取\n1 2 for chunk in pd.read_csv(\u0026#39;big_file.csv\u0026#39;, chunksize=1000): process(chunk) # 每次处理1000行 编码问题：如果遇到编码错误，试试 encoding='latin1' 或 encoding='utf-8-sig'\n性能优化：dtype 参数指定列数据类型可以节省内存\n希望这篇指南能帮助你轻松处理 CSV 数据！🎉 遇到问题时记得查阅文档哦～ (ノ◕ヮ◕)ノ*:･ﾟ✧\n","date":"2025-01-01T00:00:00Z","image":"//localhost:1313/p/program-python-basic-12/prog-python-basic-13_hu_857d88d6b0a3b5cd.jpeg","permalink":"//localhost:1313/p/program-python-basic-13/","title":"Python Basic 13 csv 文件操作"},{"content":"基础库介绍 📚 openpyxl (推荐⭐) 1 pip install openpyxl xlrd/xlwt (老牌但有点旧) 1 pip install xlrd xlwt pandas (数据分析神器) 1 pip install pandas openpyxl 基础操作 🛠️ 创建新xlsx文件 ✨ 1 2 3 4 5 6 7 8 9 10 from openpyxl import Workbook wb = Workbook() # 创建新工作簿 ws = wb.active # 获取活动工作表 ws.title = \u0026#34;我的表表\u0026#34; # 改个可爱的名字~ ws[\u0026#39;A1\u0026#39;] = \u0026#34;你好呀~\u0026#34; # 写入A1单元格 ws[\u0026#39;B1\u0026#39;] = \u0026#34;😊😊😊\u0026#34; wb.save(\u0026#34;我的第一个xlsx.xlsx\u0026#34;) # 保存文件 读取已有文件 👀 1 2 3 4 5 6 7 from openpyxl import load_workbook wb = load_workbook(\u0026#34;我的第一个xlsx.xlsx\u0026#34;) print(wb.sheetnames) # 打印所有工作表名 ws = wb[\u0026#34;我的表表\u0026#34;] # 选择特定工作表 print(ws[\u0026#39;A1\u0026#39;].value) # 读取A1的值 → \u0026#34;你好呀~\u0026#34; 常用操作大全 💫 读写单元格 (超简单!) 1 2 3 4 5 6 # 写入 ws.cell(row=2, column=1, value=\u0026#34;第二行第一列\u0026#34;) # A2单元格 ws[\u0026#34;B2\u0026#34;] = 12345 # 读取 print(ws[\u0026#34;B2\u0026#34;].value) # → 12345 遍历数据 🔄 1 2 3 4 5 6 7 8 9 for row in ws.iter_rows(min_row=1, max_col=2, max_row=2): for cell in row: print(f\u0026#34;单元格 {cell.coordinate} 的值是: {cell.value}\u0026#34;) # 输出： # 单元格 A1 的值是: 你好呀~ # 单元格 B1 的值是: 😊😊😊 # 单元格 A2 的值是: 第二行第一列 # 单元格 B2 的值是: 12345 修改样式 🎨 1 2 3 4 5 6 7 8 9 from openpyxl.styles import Font, Color # 设置字体样式 ws[\u0026#34;A1\u0026#34;].font = Font(name=\u0026#34;微软雅黑\u0026#34;, size=12, bold=True, color=\u0026#34;FF0000\u0026#34;) # 设置背景色 (需要导入PatternFill) from openpyxl.styles import PatternFill yellow_fill = PatternFill(start_color=\u0026#34;FFFF00\u0026#34;, end_color=\u0026#34;FFFF00\u0026#34;, fill_type=\u0026#34;solid\u0026#34;) ws[\u0026#34;B1\u0026#34;].fill = yellow_fill 用pandas操作xlsx (更高效!) 🐼 读取数据 1 2 3 4 5 6 7 import pandas as pd # 读取整个文件 df = pd.read_excel(\u0026#34;数据.xlsx\u0026#34;, sheet_name=\u0026#34;Sheet1\u0026#34;) # 读取部分数据 df = pd.read_excel(\u0026#34;数据.xlsx\u0026#34;, usecols=\u0026#34;A:C\u0026#34;, nrows=100) # 只读A-C列，前100行 写入数据 1 2 3 4 5 6 7 8 9 10 # 创建DataFrame data = { \u0026#34;姓名\u0026#34;: [\u0026#34;小明\u0026#34;, \u0026#34;小红\u0026#34;, \u0026#34;小刚\u0026#34;], \u0026#34;年龄\u0026#34;: [20, 19, 21], \u0026#34;成绩\u0026#34;: [98, 85, 92] } df = pd.DataFrame(data) # 写入Excel df.to_excel(\u0026#34;学生数据.xlsx\u0026#34;, sheet_name=\u0026#34;学生表\u0026#34;, index=False) 高级技巧 🔥 操作多个工作表 1 2 3 4 5 6 7 8 9 10 11 wb = Workbook() # 添加多个工作表 ws1 = wb.create_sheet(\u0026#34;一月数据\u0026#34;) ws2 = wb.create_sheet(\u0026#34;二月数据\u0026#34;) # 在不同表写入数据 ws1[\u0026#34;A1\u0026#34;] = \u0026#34;一月销售额\u0026#34; ws2[\u0026#34;A1\u0026#34;] = \u0026#34;二月销售额\u0026#34; wb.save(\u0026#34;月度报告.xlsx\u0026#34;) 公式计算 1 2 ws[\u0026#34;C1\u0026#34;] = \u0026#34;总和\u0026#34; ws[\u0026#34;C2\u0026#34;] = \u0026#34;=SUM(B1:B2)\u0026#34; # 写入Excel公式 插入图片 1 2 3 4 from openpyxl.drawing.image import Image logo = Image(\u0026#34;logo.png\u0026#34;) # 加载图片 ws.add_image(logo, \u0026#34;D5\u0026#34;) # 插入到D5单元格位置 这样操作xlsx文件是不是超简单呢？(ﾉ◕ヮ◕)ﾉ*:･ﾟ✧ 快去试试吧！遇到问题可以在评论区提问哦~ 💕\n","date":"2025-01-01T00:00:00Z","image":"//localhost:1313/p/program-python-basic-13/prog-python-basic-14_hu_857d88d6b0a3b5cd.jpeg","permalink":"//localhost:1313/p/program-python-basic-14/","title":"Python Basic 14 xlsx 文件操作"},{"content":"pyplot 是 matplotlib 库中的一个模块，提供了类似 MATLAB 的绘图接口。这篇指南帮你快速掌握 pyplot 的常用方法！(≧▽≦)\n基本设置 1 2 3 import matplotlib.pyplot as plt # 下面这条命令可以让图形在Jupyter Notebook中直接显示哦～ %matplotlib inline 最简单的折线图 📈 1 2 3 plt.plot([1, 2, 3, 4]) # y值自动生成 plt.ylabel(\u0026#39;纵轴标签\u0026#39;) # 添加纵轴标签 plt.show() # 显示图形 完整版折线图 🖍️ 1 2 3 4 5 6 7 8 9 x = [1, 2, 3, 4] y = [1, 4, 9, 16] plt.plot(x, y, \u0026#39;ro-\u0026#39;) # \u0026#39;r\u0026#39;红色, \u0026#39;o\u0026#39;圆点, \u0026#39;-\u0026#39;实线 plt.title(\u0026#39;漂亮的折线图\u0026#39;) # 添加标题 plt.xlabel(\u0026#39;x轴\u0026#39;) # 添加x轴标签 plt.ylabel(\u0026#39;y轴\u0026#39;) # 添加y轴标签 plt.grid(True) # 显示网格 plt.show() 同时绘制多个图形 🌈 1 2 3 4 5 6 7 8 9 10 11 import numpy as np # 生成0到5之间均匀分布的100个数 t = np.linspace(0, 5, 100) plt.plot(t, t, \u0026#39;r--\u0026#39;, label=\u0026#39;线性\u0026#39;) # 红色虚线 plt.plot(t, t**2, \u0026#39;bs-\u0026#39;, label=\u0026#39;平方\u0026#39;) # 蓝色方块实线 plt.plot(t, t**3, \u0026#39;g^:\u0026#39;, label=\u0026#39;立方\u0026#39;) # 绿色三角点线 plt.legend() # 显示图例 plt.show() 散点图绘制 ✨ 1 2 3 4 5 6 7 8 x = np.random.randn(100) # 100个随机数 y = np.random.randn(100) colors = np.random.rand(100) # 生成颜色 sizes = 1000 * np.random.rand(100) # 生成大小 plt.scatter(x, y, c=colors, s=sizes, alpha=0.5) plt.colorbar() # 显示颜色条 plt.show() 柱状图绘制 🏗️ 1 2 3 4 5 6 labels = [\u0026#39;苹果\u0026#39;, \u0026#39;香蕉\u0026#39;, \u0026#39;橙子\u0026#39;, \u0026#39;梨\u0026#39;] values = [20, 35, 30, 15] plt.bar(labels, values, color=[\u0026#39;r\u0026#39;, \u0026#39;y\u0026#39;, \u0026#39;orange\u0026#39;, \u0026#39;g\u0026#39;]) plt.title(\u0026#39;水果销量\u0026#39;) plt.show() 饼图绘制 🥧 1 2 3 4 5 6 7 8 labels = [\u0026#39;苹果\u0026#39;, \u0026#39;香蕉\u0026#39;, \u0026#39;橙子\u0026#39;, \u0026#39;梨\u0026#39;] sizes = [15, 30, 45, 10] explode = (0, 0.1, 0, 0) # 突出显示香蕉 plt.pie(sizes, explode=explode, labels=labels, autopct=\u0026#39;%1.1f%%\u0026#39;, shadow=True, startangle=90) plt.axis(\u0026#39;equal\u0026#39;) # 保证是圆形 plt.show() 3D 绘图 🔮 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from mpl_toolkits.mplot3d import Axes3D fig = plt.figure() ax = fig.add_subplot(111, projection=\u0026#39;3d\u0026#39;) x = np.random.rand(100) y = np.random.rand(100) z = np.random.rand(100) ax.scatter(x, y, z, c=\u0026#39;r\u0026#39;, marker=\u0026#39;o\u0026#39;) ax.set_xlabel(\u0026#39;X Label\u0026#39;) ax.set_ylabel(\u0026#39;Y Label\u0026#39;) ax.set_zlabel(\u0026#39;Z Label\u0026#39;) plt.show() 常见定制选项 🎨 参数 说明 示例值 color 颜色 \u0026lsquo;r\u0026rsquo;, \u0026lsquo;green\u0026rsquo;, \u0026lsquo;#FF00FF\u0026rsquo; linestyle 线型 \u0026lsquo;-\u0026rsquo;, \u0026lsquo;\u0026ndash;\u0026rsquo;, \u0026lsquo;:\u0026rsquo;, \u0026lsquo;-.\u0026rsquo; linewidth 线宽 2, 3.5 marker 标记 \u0026lsquo;o\u0026rsquo;, \u0026rsquo;s\u0026rsquo;, \u0026lsquo;^\u0026rsquo;, \u0026lsquo;+\u0026rsquo; alpha 透明度 0.5, 1.0 保存图片 💾 1 2 plt.plot(range(10)) plt.savefig(\u0026#39;my_plot.png\u0026#39;, dpi=300, bbox_inches=\u0026#39;tight\u0026#39;) 记得保存图片后再 plt.show() 哦，因为 show() 会清除当前的图形对象呢！(◕‿◕✿)\n祝你绘图愉快！✨\n","date":"2025-01-01T00:00:00Z","image":"//localhost:1313/p/program-python-basic-14/prog-python-basic-15_hu_857d88d6b0a3b5cd.jpeg","permalink":"//localhost:1313/p/program-python-basic-15/","title":"Python Basic 15 pyplot 常用绘图操作"},{"content":"123 sdf\n","date":"2022-03-07T00:00:00Z","image":"//localhost:1313/p/history-french-a/covera_hu_a1d989403ce900c4.png","permalink":"//localhost:1313/p/history-french-a/","title":"法国历史简介"},{"content":"Bash三剑客：grep, sed, awk 全面解析 (＾▽＾)ﾉ♪ 作为Linux系统中的三大文本处理神器，bash三剑客是每位研究生的必备技能！让我们一起来深入探索它们的强大功能吧～(ﾉ◕ヮ◕)ﾉ*:･ﾟ✧\ngrep：文本搜索小能手 1 grep [选项] 模式 [文件...] grep(Global Regular Expression Print)是最常用的文本搜索工具，主要功能是在文件中查找匹配特定模式的文本行。\n常用选项：\n-i：忽略大小写 -v：反向选择，显示不匹配的行 -n：显示行号 -c：统计匹配行数 -r 或 -R：递归搜索目录 -E：使用扩展正则表达式(等效于egrep) 数学表达式匹配示例(使用-P支持Perl正则)：\n1 2 grep -P \u0026#39;\\d+\\.\\d+\u0026#39; file.txt # 匹配浮点数 grep -P \u0026#39;x\\^2 \\+ y\\^2 = \\d+\u0026#39; equation.txt # 匹配x²+y²=数字 sed：流编辑器大师 1 sed [选项] \u0026#39;命令\u0026#39; 输入文件 sed(Stream EDitor)是非交互式的流编辑器，擅长对文本进行逐行处理。\n核心命令格式：\n1 [地址范围] 动作 [参数] 常用操作：\ns：替换 sed 's/old/new/g' file (｀・ω・´) d：删除 sed '/pattern/d' file p：打印 sed -n '/pattern/p' file a：追加 sed '3a\\new line' file i：插入 sed '2i\\insert line' file 科研数据处理示例：\n1 2 3 4 5 # 将CSV中的科学计数法转换为普通小数 sed -E \u0026#39;s/([0-9]+)\\.([0-9]+)e-([0-9]+)/0\\.\\2\\1 \\3/g\u0026#39; data.csv # 批量重命名文件中的变量 find . -name \u0026#34;*.py\u0026#34; | xargs sed -i \u0026#39;s/old_var/new_var/g\u0026#39; awk：文本处理瑞士军刀 1 awk [选项] \u0026#39;模式 {动作}\u0026#39; 文件 awk是一种强大的文本处理编程语言，特别适合处理结构化数据(如表格)。\n基本结构：\n1 2 3 BEGIN { 初始化操作 } /pattern/ { 模式匹配时的操作 } END { 结束处理时的操作 } 内置变量：\nNR：当前记录数(行号) NF：当前记录的字段数 FS：输入字段分隔符(默认空格或制表符) OFS：输出字段分隔符 数学计算示例(・ω\u0026lt;)★：\n1 2 3 4 5 # 计算CSV文件第二列的平均值 awk -F, \u0026#39;NR\u0026gt;1 {sum+=$2; count++} END {print \u0026#34;平均值为:\u0026#34;, sum/count}\u0026#39; data.csv # 解一元二次方程ax²+bx+c=0 (输入a,b,c三个系数) echo \u0026#34;1 5 6\u0026#34; | awk \u0026#39;{a=$1;b=$2;c=$3;delta=b^2-4*a*c;x1=(-b+sqrt(delta))/(2*a);x2=(-b-sqrt(delta))/(2*a);print \u0026#34;x1=\u0026#34;x1,\u0026#34;x2=\u0026#34;x2}\u0026#39; 三剑客组合技 (ง •_•)ง 它们的真正威力在于组合使用！看个复杂例子：\n1 2 3 4 5 # 统计日志中不同HTTP状态码出现的次数，按降序排列 grep -oP \u0026#39;HTTP/1.\\d\u0026#34; \\K\\d{3}\u0026#39; access.log | sort | uniq -c | sort -nr | awk \u0026#39;{print \u0026#34;状态码\u0026#34;,$2,\u0026#34;出现\u0026#34;,$1,\u0026#34;次\u0026#34;}\u0026#39; # 提取Latex论文中的数学公式并编号 grep -nP \u0026#39;\\\\begin\\{equation\\}\u0026#39; paper.tex | sed \u0026#39;s/$[0-9]\\+$:.*/sed -n \u0026#34;\\1,/\\\\\\\\end{equation}/p\u0026#34; paper.tex/e\u0026#39; | awk \u0026#39;{print \u0026#34;公式\u0026#34;NR\u0026#34;: \u0026#34;$0}\u0026#39; 性能优化小贴士 ٩(◕‿◕｡)۶ 减少管道次数：尽可能在一个命令中完成更多操作 提前过滤：先用grep过滤掉无关行再处理 使用最合适的工具： 简单搜索 → grep 简单替换 → sed 复杂处理 → awk 利用并行处理：对于大文件，可以考虑使用parallel命令 进阶学习资源 ╰(°▽°)╯ 官方文档：man grep, info sed, man awk 经典书籍： 《sed \u0026amp; awk》 by Dale Dougherty 《精通正则表达式》 by Jeffrey Friedl 在线教程： GNU awk用户指南 grepbible (grep技巧大全) 记住，bash三剑客的学习需要大量实践！试着用它们来处理你的论文数据、实验日志或代码文件吧～(ﾉ\u0026gt;ω\u0026lt;)ﾉ\n","date":"2022-03-06T00:00:00Z","image":"//localhost:1313/p/program-bash-sanjianke/cover_hu_857d88d6b0a3b5cd.jpeg","permalink":"//localhost:1313/p/program-bash-sanjianke/","title":"Bash 三剑客"},{"content":"Clojure中的数据类型详解 Clojure作为一门函数式编程语言，提供了一组丰富的数据类型。下面我将详细介绍Clojure中的核心数据类型及其特性。\n基本数据类型 数值(Number)类型 1 2 3 4 5 42 ; 整数 3.14 ; 浮点数 1/3 ; 分数(Ratio) 0xff ; 十六进制 2r1010 ; 二进制 原子(Atom)类型 1 2 3 4 :keyword ; 关键字(常作为键使用) \u0026#39;symbol ; 符号(表示标识符) true ; 布尔值 nil ; 空值 集合数据类型 字符串(String) 1 2 \u0026#34;Hello, Clojure!\u0026#34; ; 双引号包裹 \\A ; 单个字符(Java char) Clojure字符串就是Java字符串，支持多行：\n1 2 \u0026#34;第一行 第二行\u0026#34; 列表(List) - 不可变链表 1 2 \u0026#39;(1 2 3 4) ; 使用单引号 (list 1 2 3 4) ; 使用list函数 链表结构，头部插入高效 不可变 常用作函数调用形式或者数据序列 向量(Vector) - 不可变数组 1 2 [1 2 3 4] ; 方括号表示 (vector 1 2 3 4) ; 使用vector函数 基于数组，随机访问高效(O(1)) 不可变 常用作有序集合存储 集合(Set) - 不可变无序不重复集合 1 2 3 #{1 2 3 4} ; 花括号前加# (hash-set 1 2 3) ; 使用hash-set函数 (sorted-set 4 2) ; 排序集合→ #{2 4} 保证元素唯一 查找速度快(O(1)) 无序存储 字典(Map) - 键值对集合 1 2 3 {:name \u0026#34;Alice\u0026#34; :age 30} ; 花括号表示 (hash-map :a 1 :b 2) ; 使用hash-map函数 (sorted-map :b 2 :a 1) ; 排序Map→ {:a 1 :b 2} 键通常是关键字(keyword) 键的唯一性保证 支持嵌套结构 特殊数据类型 记录(Record) 1 2 3 (defrecord Person [name age]) (def alice (-\u0026gt;Person \u0026#34;Alice\u0026#34; 30)) (:name alice) ; 访问字段→ \u0026#34;Alice\u0026#34; 类似结构体 固定字段集合 实现Map接口 数组(Array) 1 2 (make-array Integer 3) ; Java数组 (int-array [1 2 3]) ; 基本类型数组 实际上是Java数组的包装 可变(mutable) 主要用于Java互操作 Clojure强调不可变数据，所有内置集合类型默认都是不可变的。要使用可变状态，需要显式使用atom、ref等引用类型来包装这些不可变数据结构。\nClojure基础语法：变量定义 Clojure作为一门Lisp方言的函数式编程语言，其变量定义方式与主流命令式语言有很大不同。以下是Clojure中主要的变量定义方式：\ndef - 定义全局变量 def用于定义全局命名空间内的变量：\n1 2 3 (def PI 3.14159) ;; 定义一个常量 (def company-name \u0026#34;TechCorp\u0026#34;) ;; 定义字符串变量 (def primes [2 3 5 7 11]) ;; 定义集合 注意：\ndef定义的变量是全局可访问的 虽然技术上可以修改(使用alter-var-root)，但惯例上应视为不可变 命名通常使用连字符，如user-name而非userName let - 定义局部绑定 let用于创建局部作用域的临时绑定：\n1 2 3 (let [radius 5 pi 3.14159] (* pi (* radius radius))) ;; 计算圆面积 特点：\n绑定只在let块内有效 绑定是并行赋值的(后面表达式不能依赖前面) 常用在函数内部定义临时变量 defn - 定义函数 虽然主要是定义函数，但也是一种变量绑定方式：\n1 2 3 4 5 (defn greet [name] (str \u0026#34;Hello, \u0026#34; name \u0026#34;!\u0026#34;)) ;; 等价于： (def greet (fn [name] (str \u0026#34;Hello, \u0026#34; name \u0026#34;!\u0026#34;))) 动态变量 (带星号) Clojure支持动态作用域变量：\n1 2 3 4 (def ^:dynamic *debug* false) (binding [*debug* true] (println \u0026#34;Debug mode:\u0026#34; *debug*)) 惯例：\n动态变量名称用*包围，如*out* 使用binding建立新的动态绑定 重要原则 不可变性：Clojure中的变量一旦定义，其值不应改变 避免全局状态：尽量使用局部绑定而非全局变量 线程安全：得益于不可变性，Clojure变量天生线程安全 这些是Clojure变量系统的基础部分，体现了其函数式编程的核心思想。\nClojure函数定义简介 Clojure作为一门函数式编程语言，函数是它的核心构建块。下面介绍Clojure中定义函数的主要方式：\n基本函数定义(defn) 使用defn宏定义命名函数：\n1 2 3 4 5 (defn function-name \u0026#34;可选的文档字符串\u0026#34; [param1 param2] ; 参数向量 (println param1 param2) ; 函数体 (+ param1 param2)) ; 隐式返回最后一个表达式 匿名函数(fn) 定义不绑定名称的函数：\n1 2 (fn [x y] (+ x y)) 或使用简写形式：\n1 #(+ %1 %2) ; %1表示第一个参数，%2表示第二个 多参数函数 Clojure支持可变参数：\n1 2 (defn sum [\u0026amp; nums] ; nums是序列 (apply + nums)) 多分派函数(defmulti/defmethod) 基于参数值选择不同实现：\n1 2 3 4 (defmulti greet :language) ; 根据:language分派 (defmethod greet :english [_] \u0026#34;Hello!\u0026#34;) (defmethod greet :spanish [_] \u0026#34;¡Hola!\u0026#34;) 高阶函数 函数可以作为参数或返回值：\n1 2 3 4 (defn apply-twice [f x] (f (f x))) (apply-twice #(* % 2) 3) ; 返回12 Clojure的函数是不可变的一等公民，这种设计支持函数组合和复用，是函数式编程的基础。\nClojure 函数重载与多参数处理综合指南 Clojure 提供了多种方式来实现类似其他语言中的函数重载功能，包括基于参数数量、类型和任意条件的分派方法。以下是综合介绍：\n基础函数多态（Multiple Arities） 最简单直接的\u0026quot;重载\u0026quot;方式是利用 Clojure 的函数多参数定义：\n1 2 3 4 5 6 7 8 9 10 11 12 (defn process \u0026#34;基础多参数实现\u0026#34; ([] (println \u0026#34;无参数调用\u0026#34;)) ([x] (println \u0026#34;单参数:\u0026#34; x)) ([x y] (println \u0026#34;双参数:\u0026#34; x y)) ([x y \u0026amp; z] (println \u0026#34;变长参数:\u0026#34; x y z))) ;; 使用示例 (process) ; 无参数调用 (process 10) ; 单参数: 10 (process 10 20) ; 双参数: 10 20 (process 1 2 3 4) ; 变长参数: 1 2 (3 4) 特点：\n最简洁的实现方式 编译时确定调用版本 性能最优 多重方法（Multimethods） 基于参数数量的分派 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 (defmulti handle-request \u0026#34;基于参数数量分派\u0026#34; (fn [\u0026amp; args] (count args))) (defmethod handle-request 0 [_] \u0026#34;处理无参数请求\u0026#34;) (defmethod handle-request 1 [[x]] (str \u0026#34;处理单请求: \u0026#34; x)) (defmethod handle-request 2 [[x y]] (str \u0026#34;处理双请求: \u0026#34; x \u0026#34;和\u0026#34; y)) (defmethod handle-request :default [args] (str \u0026#34;处理复杂请求: \u0026#34; (pr-str args))) 基于参数类型的分派 1 2 3 4 5 6 7 8 9 10 11 12 (defmulti calculate \u0026#34;基于参数类型分派\u0026#34; (fn [x y] [(class x) (class y)])) (defmethod calculate [Number Number] [x y] (+ x y)) (defmethod calculate [String String] [x y] (str x y)) (defmethod calculate [Number String] [x y] (str x y)) 层级分派（Hierarchical Dispatch） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 (defmulti render (fn [shape] (:type shape))) ;; 定义类型层次关系 (derive ::circle ::shape) (derive ::square ::shape) (defmethod render ::circle [_] \u0026#34;绘制圆形\u0026#34;) (defmethod render ::square [_] \u0026#34;绘制方形\u0026#34;) (defmethod render ::shape [_] \u0026#34;默认形状绘制\u0026#34;) 协议与记录（Protocols \u0026amp; Records） 适用于面向对象风格的重载：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 (defprotocol DataProcessor (process-data [this]) (process-data [this input]) (process-data [this input options])) (defrecord DefaultProcessor [] DataProcessor (process-data [this] \u0026#34;无参数处理\u0026#34;) (process-data [this input] (str \u0026#34;处理输入: \u0026#34; input)) (process-data [this input options] (str \u0026#34;处理输入 \u0026#34; input \u0026#34; 带选项 \u0026#34; options))) (let [p (DefaultProcessor.)] [(process-data p) (process-data p \u0026#34;data\u0026#34;) (process-data p \u0026#34;data\u0026#34; {:format :json})]) 综合使用示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 ;; 定义形状协议 (defprotocol Shape (area [this]) (perimeter [this])) ;; 实现圆形 (defrecord Circle [radius] Shape (area [this] (* Math/PI radius radius)) (perimeter [this] (* 2 Math/PI radius))) ;; 实现矩形 - 使用多参数构造 (defn make-rectangle ([side] (make-rectangle side side)) ; 正方形 ([width height] (Rectangle. width height))) (defrecord Rectangle [width height] Shape (area [this] (* width height)) (perimeter [this] (* 2 (+ width height)))) ;; 定义针对形状的多重方法 (defmulti draw :type) (defmethod draw :circle [{r :radius}] (str \u0026#34;绘制圆形，半径 \u0026#34; r)) (defmethod draw :rectangle [{w :width h :height}] (str \u0026#34;绘制矩形 \u0026#34; w \u0026#34;x\u0026#34; h)) 选择指南 特性 多参数函数 多重方法 协议 参数数量分派 ✓ ✓ ✓ 参数类型分派 ✗ ✓ ✓ 自定义条件分派 ✗ ✓ ✗ 性能 最优 中等 高 扩展性 有限 强 中等 代码组织 简单 灵活 结构化 推荐选择：\n优先使用简单的多参数函数实现基础重载 需要复杂分派逻辑时使用多重方法 定义数据类型行为时使用协议 Clojure 的这些特性共同构成了比传统面向对象语言更灵活的多态系统，开发者可以根据具体需求选择最合适的实现方式。\nClojure宏：代码的代码 Clojure宏(Macro)是一种元编程工具，允许你在编译时对代码进行转换，而不是在运行时处理数据。宏是Lisp家族语言最强大的特性之一，让语言具有真正的可扩展性。\n宏的基本概念 宏与普通函数的关键区别：\n执行时机：函数在运行时执行，宏在编译时展开 参数处理：函数会先对参数求值，宏接收未求值的表达式 定义宏 使用defmacro定义宏：\n1 2 3 (defmacro macro-name [params] ; 返回可以求值的表达式 ) 简单宏示例 unless宏 1 2 3 4 5 6 7 8 (defmacro unless [condition \u0026amp; body] `(if (not ~condition) (do ~@body))) ; 使用 (unless (= 2 (+ 1 1)) (println \u0026#34;Math is broken!\u0026#34;) (println \u0026#34;This should never print\u0026#34;)) 这个宏实现了与if not相反的逻辑，展开后变为：\n1 2 3 4 (if (not (= 2 (+ 1 1))) (do (println \u0026#34;Math is broken!\u0026#34;) (println \u0026#34;This should never print\u0026#34;))) infix宏 1 2 3 4 5 6 7 (defmacro infix [form] (list (second form) (first form) (nth form 2))) ; 使用 (infix (2 + 3)) ; =\u0026gt; 5 这个宏允许使用中缀表示法（如2 + 3）进行数学运算。\n高级宏技术 语法引号与解引 在宏中常用反引号(`)创建模板，使用~解引用符号：\n1 2 3 4 (defmacro debug [expr] `(let [result# ~expr] (println \u0026#34;Debug:\u0026#34; \u0026#39;~expr \u0026#34;=\u0026gt;\u0026#34; result#) result#)) result#会自动生成唯一的符号名，避免名称冲突。\n使用macroexpand理解宏 1 2 (macroexpand \u0026#39;(unless true (println \u0026#34;No\u0026#34;))) ; 输出：(if (clojure.core/not true) (do (println \u0026#34;No\u0026#34;))) 实际应用案例 性能计时宏 1 2 3 4 5 6 7 8 (defmacro time-exec \u0026#34;执行表达式并返回执行时间和结果\u0026#34; [expr] `(let [start# (System/currentTimeMillis) result# ~expr end# (System/currentTimeMillis)] {:result result# :time (- end# start#)})) 领域特定语言(DSL) 宏可以创建自定义语法：\n1 2 3 4 5 6 7 (defmacro define-route [method path args \u0026amp; body] `(defroutes ~(symbol (str method \u0026#34;-\u0026#34; (name path))) (~method ~path ~args (do ~@body)))) (define-route GET \u0026#34;/user/:id\u0026#34; [id] (str \u0026#34;User ID: \u0026#34; id)) 宏的最佳实践 优先使用函数：能用函数解决的不要用宏 保持简单：宏应该聚焦在语法转换上 避免意外捕获变量：使用自动生成的符号名(如var#) 文档齐全：宏比函数更难理解，需要更好的文档 总结 Clojure宏提供了一种强大的代码生成机制，允许你扩展语言本身。虽然强大，但也需要谨慎使用。理解宏的关键是记住它们在编译阶段处理代码，而不是在运行时处理数据。\n通过合理使用宏，可以消除重复代码、创建领域特定语言，以及实现超出核心语言语法的功能。\n","date":"2022-03-06T00:00:00Z","image":"//localhost:1313/p/clojure-basic-var-and-fun/clojure-basic-a-cover_hu_a57c751c972cbad7.png","permalink":"//localhost:1313/p/clojure-basic-var-and-fun/","title":"Clojure 基础语法 —— 变量和函数"},{"content":"罗马不列颠（43-410年） 征服过程：克劳迪乌斯动用4万军队，镇压凯尔特女王布狄卡起义（60年）。 基建遗产： 伦敦（Londinium）成为贸易中心，修建罗马式道路（如福斯路）。 巴斯温泉浴场体现罗马生活方式。 衰落原因：帝国收缩防御，北方皮克特人侵袭，409年罗马驻军撤离。 背景 公元前1世纪，不列颠岛屿主要由凯尔特部落（如爱西尼人、布里甘特人等）统治。罗马共和国曾于前55年、前54年两次入侵（尤利乌斯·恺撒率军），但未建立长期统治。\n征服与建立行省（43-84年） 43年：罗马皇帝克劳狄乌斯派军4万入侵不列颠，击败当地部落，建立行省\u0026quot;不列颠尼亚\u0026quot;（Britannia），首府初设科尔切斯特（Camulodunum）。 60年：爱西尼部落女王布狄卡（Boudica）起义，焚毁伦敦（Londinium）、科尔切斯特等城市，后被罗马镇压。 70-84年：罗马总督阿古利可拉（Agricola）向北部扩张，至84年基本控制今英格兰地区，并在苏格兰击败喀里多尼亚人（但未永久占领）。 罗马化与建设（2-3世纪） 城市发展：建立伦敦（商业中心）、约克（Eboracum，军事重镇）、巴斯（温泉疗养地）等城市，引入罗马式建筑（神庙、浴场、剧院）。 基础设施：修筑道路（如福斯路Fosse Way）、哈德良长城（122年建于英格兰北部，防御苏格兰部落）。 经济：开采锡、铅矿，发展农业（引入葡萄种植），与帝国其他行省贸易。 宗教：罗马多神教与本地信仰融合，后期基督教传入（约3世纪）。 危机与衰落（3-4世纪） 外患：撒克逊海盗袭扰东部海岸，皮克特人（苏格兰）、斯科特人（爱尔兰）进攻北部。 内乱：286年，海军将领卡劳修斯（Carausius）自立为不列颠皇帝，293年被镇压。 行政调整：4世纪，不列颠被分为4个行省，军事防御加强（如建造\u0026quot;撒克逊海岸堡垒\u0026quot;）。 罗马撤离（410年） 407年：将领君士坦丁三世带军队撤离不列颠，前往高卢争夺帝位。 410年：皇帝霍诺留发信告知不列颠人\u0026quot;自谋防御\u0026quot;，标志罗马统治正式结束。当地罗马-不列颠人逐渐形成自治政权，但陷入分裂。 遗产 文化：拉丁语影响、基督教基础、城市与法律传统。 遗迹：哈德良长城、巴斯浴场、伦敦城墙等至今可见。 罗马撤离后，不列颠进入\u0026quot;后罗马时期\u0026quot;，为盎格鲁-撒克逊人的入侵埋下伏笔。\n盎格鲁-撒克逊七国（5-9世纪） 社会结构：\n阶层 职责 国王 军事领袖，依赖亲兵（thegn） 自由农 缴纳粮食税（feorm） 奴隶 战俘或债务奴隶 文化标志：\n《贝奥武甫》（8世纪）：现存最古英语史诗，反映英雄价值观。 林迪斯法恩福音书：彩饰手抄本，代表基督教化艺术成就。 背景：罗马不列颠的结束（5世纪初） 罗马帝国于410年从不列颠撤军，结束近400年统治 当地凯尔特-不列颠人失去保护，面临皮克特人（苏格兰）和斯科特人（爱尔兰）侵扰 传说：不列颠王沃蒂根邀请日耳曼部落（盎格鲁人、撒克逊人、朱特人）协助防御 七国时代（Heptarchy）的形成 约6-8世纪，日耳曼移民建立七大主要王国：\n肯特（Kent）：朱特人建立，第一个基督教化王国（597年） 威塞克斯（Wessex）：撒克逊人建立，后成为统一英格兰的核心 埃塞克斯（Essex）、萨塞克斯（Sussex）：东/南撒克逊人 东盎格利亚（East Anglia）：盎格鲁人建立 麦西亚（Mercia）：中部强国，8世纪称霸 诺森布里亚（Northumbria）：北方联盟，文化中心（林迪斯法恩修道院） 关键发展阶段 基督教化（6-7世纪） 597年：教皇格里高利派奥古斯丁至肯特传教 663年惠特比会议：罗马基督教击败凯尔特基督教成为主流 麦西亚霸权（8世纪） 奥法（Offa, 757-796年）统治时期： 修建\u0026quot;奥法堤\u0026quot;（威尔士边界） 发行银便士，建立早期货币体系 维京入侵（9世纪） 793年：林迪斯法恩修道院遭袭，开启\u0026quot;维京时代\u0026quot; 865年：维京大军占领东盎格利亚、诺森布里亚 878年：威塞克斯的阿尔弗雷德大帝（Alfred the Great）在爱丁顿战役获胜，签订《韦德莫尔和约》，保住英格兰西南部 重要遗产 语言：古英语形成（《贝奥武夫》史诗） 法律：早期法典（如《阿尔弗雷德法典》） 行政区划：郡（Shire）制度雏形 统一基础：威塞克斯王朝后期逐渐统一英格兰 时间线结尾 927年：阿尔弗雷德之孙埃塞尔斯坦（Æthelstan）成为首位\u0026quot;英格兰国王\u0026quot; 1016年：丹麦人克努特大帝建立北海帝国，短暂终结盎格鲁-撒克逊统治 这个时期奠定了英格兰的族群构成、语言文化和政治框架，被视为英国民族国家的起源阶段。如需某一具体领域（如宗教、战争、日常生活）的细节可继续探讨。\n诺曼王朝（1066-1154年） 统治技术：\n封建体系： 国王→男爵（分封土地）→骑士（年服役40天）。 1086年《末日审判书》记录13,418个定居点，精准征税。 建筑威慑：伦敦塔白塔（1078年）兼堡垒与王宫，象征诺曼权威。 王朝奠基：征服者威廉的统治（1066-1087年） 1066年黑斯廷斯战役后，诺曼底公爵威廉击败盎格鲁-撒克逊军队，加冕为英格兰国王（史称威廉一世）。其统治核心举措包括：\n土地再分配：没收英格兰贵族土地，分封给诺曼追随者，建立封建采邑制 《末日审判书》（1086年）：首次全国土地普查，确立王权对资源的绝对控制 建筑遗产：伦敦塔、达勒姆大教堂等罗马式建筑彰显诺曼权威 王权巩固与继承危机 威廉二世（1087-1100年） 强化军事统治，持续征收重税，在狩猎中离奇身亡，疑为弟弟亨利策划。\n亨利一世（1100-1135年）\n颁布《自由宪章》争取支持 建立枢密院制度雏形 王室舰队建设提升海军力量 1120年\u0026quot;白船事件\u0026quot;导致继承人溺亡，引发继承危机 内战动荡：斯蒂芬与玛蒂尔达的争夺（1135-1154年） 亨利一世死后，其外甥斯蒂芬与女儿玛蒂尔达爆发长期内战：\n双方僵局：玛蒂尔达（安茹伯爵夫人）联合法国势力对抗 《温彻斯特条约》（1153年）约定由玛蒂尔达之子亨利继位 战争造成\u0026quot;十九年无政府状态\u0026quot;，地方城堡数量激增至500余座 诺曼遗产 行政体系\n引入诺曼底官僚制度 拉丁语成为官方语言 组建国王法庭（Curia Regis） 社会变迁\n法语成为贵族语言（持续至14世纪） 融合盎格鲁-撒克逊与诺曼法制传统 骑士制度与封建义务体系确立 文化影响\n罗马式建筑风格盛行 贵族家谱记录开始规范化 促进英格兰与欧洲大陆的文化交流 1154年亨利二世（玛蒂尔达之子）继位，开启金雀花王朝，诺曼时代正式终结，但其建立的行政框架为未来英格兰的中央集权奠定了基础。\n百年战争（1337-1453年） 关键战役对比：\n战役 年份 战术创新 结果 克雷西 1346 英格兰长弓破骑兵 法军阵亡1.5万 阿金库尔 1415 泥地困住法军重甲 亨利五世重占诺曼底 长期影响：议会借战争扩大征税权，法语退出上层用语。\n战争背景 王位继承问题：1328年法国卡佩王朝绝嗣，英王爱德华三世（1327-1377在位）以法王腓力四世外孙身份争夺王位。 领土争端：英格兰在法国保有阿基坦等领地，法王欲收回。 经济因素：佛兰德斯的羊毛贸易利益驱动英格兰参战。 战争第一阶段（1337-1360） 关键战役： 1340年斯勒伊斯海战：英军取得制海权 1346年克雷西战役：英格兰长弓兵大败法国重骑兵 1356年普瓦捷战役：黑太子爱德华俘虏法王约翰二世 《布雷蒂尼和约》（1360）：英格兰获得加莱及法国西南部大片领土 国内发展（1360-1415） 理查二世统治（1377-1399）： 1381年瓦特·泰勒农民起义 1399年被亨利四世废黜，金雀花王朝终结 兰开斯特王朝建立： 亨利四世（1399-1413）巩固王权 镇压珀西家族叛乱（1403年什鲁斯伯里战役） 战争高潮（1415-1429） 亨利五世（1413-1422）： 1415年阿金库尔战役：以少胜多歼灭法国骑士 1420年《特鲁瓦条约》：获法王继承人资格 婴儿国王亨利六世（1422-1461）： 1428年围困奥尔良 1429年圣女贞德解围，扭转战局 战争尾声（1429-1453） 法国反攻： 1435年勃艮第倒戈 1450年福尔米尼战役失利 最终结果： 1453年英军失去除加莱外所有大陆领土 战争开支导致王室财政崩溃 后续影响 直接引发玫瑰战争（1455-1485） 推动英格兰民族意识形成 议会权力在战争征税中增强 补充说明：战争期间英格兰人口因黑死病（1348-1349）减少约三分之一，促进了农奴制瓦解。军事技术方面，长弓战术和早期火器改变了战争形态。\n宗教改革（1530s-1558年） 亨利八世步骤：\n1529年：以凯瑟琳无子为由申请离婚，遭教皇拒绝。 1534年《至尊法案》：英王成教会最高领袖，关闭600座修道院。 文化控制：1538年要求每教堂置英文《圣经》，削弱拉丁语权威。 这个时期的核心是亨利八世主导的英格兰宗教改革，以及其子女统治时期的宗教反复，史称\u0026quot;英格兰宗教改革时期\u0026quot;。整个过程充满政治博弈与血腥镇压，彻底改变了英国国教体系。\n亨利八世时期（1509-1547） 关键事件：\n离婚案触发改革（1527-1533）\n亨利八世因无男性继承人，要求与凯瑟琳离婚遭教皇拒绝 议会通过《上诉限制法案》（1533）禁止向罗马教廷上诉 确立王权至尊（1534）\n《至尊法案》宣布英王为英国教会最高领袖 托马斯·莫尔因拒绝承认被处死（1535） 解散修道院（1536-1541）\n王室没收修道院财产，增强王室财力 引发\u0026quot;求恩巡礼\u0026quot;起义（1536），遭镇压 爱德华六世时期（1547-1553） 改革激进化的新教时期：\n颁布《公祷书》（1549/1552） 制定《四十二条信纲》（1553） 激进新教徒掌权，摧毁天主教圣像 \u0026ldquo;血腥玛丽\u0026quot;时期（1553-1558） 天主教全面复辟：\n玛丽一世继位后：\n废除父亲与弟弟的宗教立法 恢复教皇权威（1554） 宗教迫害：\n约300名新教徒被处死，包括大主教克兰麦 获得\u0026quot;血腥玛丽\u0026quot;称号 政治危机：\n与西班牙腓力二世联姻引发民众不满 失去加莱港（1558），英国在欧洲大陆最后据点 改革特点 自上而下的改革，政治动机大于宗教虔诚 形成独特的英国国教会（安立甘宗） 埋下了此后百年宗教冲突的伏笔 通过这段历史可以看到，英国的宗教改革本质上是一场由王室主导、议会支持的政治革命，为新教在英国的传播奠定了基础，也为伊丽莎白时代的宗教和解创造了条件。\n工业革命（1760-1840年） 技术创新链：\n纺织业： 1733飞梭（凯伊）→1764珍妮纺纱机（哈格里夫斯）→1785水力织布机。 能源： 1712纽科门蒸汽机→1776瓦特改良版（效提率升5倍）。 社会代价：曼彻斯特工人1819年平均寿命仅17岁，催生《工厂法》（1833）。\n二战与战后（1939-1950s） 关键数据：\n闪电战损失：1940-1941年伦敦遭7.6万吨炸弹，4.3万平民死。 福利国家：1942年《贝弗里奇报告》奠基全民医保（NHS成立于1948）。 帝国解体速度：1947-1965年间，12个主要殖民地独立。 脱欧背景（2016-2020年） 核心矛盾：\n移民问题：欧盟东扩后英国净移民数从2004年24万升至2015年33万。 主权争议：欧洲法院对英国司法干预案件1973-2015年累计143起。 经济影响：2021年对欧贸易额同比下降15.7%，金融业岗位外流1.2万。\n","date":"2022-03-06T00:00:00Z","image":"//localhost:1313/p/history-england-a/coverb_hu_15516e5b362087f6.png","permalink":"//localhost:1313/p/history-england-a/","title":"英国历史简介1"}]