[{"content":"123 sdf\n","date":"2022-03-07T00:00:00Z","image":"//localhost:1313/p/history-french-a/covera_hu_a1d989403ce900c4.png","permalink":"//localhost:1313/p/history-french-a/","title":"法国历史简介"},{"content":"Bash三剑客：grep, sed, awk 全面解析 (＾▽＾)ﾉ♪ 作为Linux系统中的三大文本处理神器，bash三剑客是每位研究生的必备技能！让我们一起来深入探索它们的强大功能吧～(ﾉ◕ヮ◕)ﾉ*:･ﾟ✧\ngrep：文本搜索小能手 1 grep [选项] 模式 [文件...] grep(Global Regular Expression Print)是最常用的文本搜索工具，主要功能是在文件中查找匹配特定模式的文本行。\n常用选项：\n-i：忽略大小写 -v：反向选择，显示不匹配的行 -n：显示行号 -c：统计匹配行数 -r 或 -R：递归搜索目录 -E：使用扩展正则表达式(等效于egrep) 数学表达式匹配示例(使用-P支持Perl正则)：\n1 2 grep -P \u0026#39;\\d+\\.\\d+\u0026#39; file.txt # 匹配浮点数 grep -P \u0026#39;x\\^2 \\+ y\\^2 = \\d+\u0026#39; equation.txt # 匹配x²+y²=数字 sed：流编辑器大师 1 sed [选项] \u0026#39;命令\u0026#39; 输入文件 sed(Stream EDitor)是非交互式的流编辑器，擅长对文本进行逐行处理。\n核心命令格式：\n1 [地址范围] 动作 [参数] 常用操作：\ns：替换 sed 's/old/new/g' file (｀・ω・´) d：删除 sed '/pattern/d' file p：打印 sed -n '/pattern/p' file a：追加 sed '3a\\new line' file i：插入 sed '2i\\insert line' file 科研数据处理示例：\n1 2 3 4 5 # 将CSV中的科学计数法转换为普通小数 sed -E \u0026#39;s/([0-9]+)\\.([0-9]+)e-([0-9]+)/0\\.\\2\\1 \\3/g\u0026#39; data.csv # 批量重命名文件中的变量 find . -name \u0026#34;*.py\u0026#34; | xargs sed -i \u0026#39;s/old_var/new_var/g\u0026#39; awk：文本处理瑞士军刀 1 awk [选项] \u0026#39;模式 {动作}\u0026#39; 文件 awk是一种强大的文本处理编程语言，特别适合处理结构化数据(如表格)。\n基本结构：\n1 2 3 BEGIN { 初始化操作 } /pattern/ { 模式匹配时的操作 } END { 结束处理时的操作 } 内置变量：\nNR：当前记录数(行号) NF：当前记录的字段数 FS：输入字段分隔符(默认空格或制表符) OFS：输出字段分隔符 数学计算示例(・ω\u0026lt;)★：\n1 2 3 4 5 # 计算CSV文件第二列的平均值 awk -F, \u0026#39;NR\u0026gt;1 {sum+=$2; count++} END {print \u0026#34;平均值为:\u0026#34;, sum/count}\u0026#39; data.csv # 解一元二次方程ax²+bx+c=0 (输入a,b,c三个系数) echo \u0026#34;1 5 6\u0026#34; | awk \u0026#39;{a=$1;b=$2;c=$3;delta=b^2-4*a*c;x1=(-b+sqrt(delta))/(2*a);x2=(-b-sqrt(delta))/(2*a);print \u0026#34;x1=\u0026#34;x1,\u0026#34;x2=\u0026#34;x2}\u0026#39; 三剑客组合技 (ง •_•)ง 它们的真正威力在于组合使用！看个复杂例子：\n1 2 3 4 5 # 统计日志中不同HTTP状态码出现的次数，按降序排列 grep -oP \u0026#39;HTTP/1.\\d\u0026#34; \\K\\d{3}\u0026#39; access.log | sort | uniq -c | sort -nr | awk \u0026#39;{print \u0026#34;状态码\u0026#34;,$2,\u0026#34;出现\u0026#34;,$1,\u0026#34;次\u0026#34;}\u0026#39; # 提取Latex论文中的数学公式并编号 grep -nP \u0026#39;\\\\begin\\{equation\\}\u0026#39; paper.tex | sed \u0026#39;s/$[0-9]\\+$:.*/sed -n \u0026#34;\\1,/\\\\\\\\end{equation}/p\u0026#34; paper.tex/e\u0026#39; | awk \u0026#39;{print \u0026#34;公式\u0026#34;NR\u0026#34;: \u0026#34;$0}\u0026#39; 性能优化小贴士 ٩(◕‿◕｡)۶ 减少管道次数：尽可能在一个命令中完成更多操作 提前过滤：先用grep过滤掉无关行再处理 使用最合适的工具： 简单搜索 → grep 简单替换 → sed 复杂处理 → awk 利用并行处理：对于大文件，可以考虑使用parallel命令 进阶学习资源 ╰(°▽°)╯ 官方文档：man grep, info sed, man awk 经典书籍： 《sed \u0026amp; awk》 by Dale Dougherty 《精通正则表达式》 by Jeffrey Friedl 在线教程： GNU awk用户指南 grepbible (grep技巧大全) 记住，bash三剑客的学习需要大量实践！试着用它们来处理你的论文数据、实验日志或代码文件吧～(ﾉ\u0026gt;ω\u0026lt;)ﾉ\n","date":"2022-03-06T00:00:00Z","image":"//localhost:1313/p/program-bash-sanjianke/cover_hu_857d88d6b0a3b5cd.jpeg","permalink":"//localhost:1313/p/program-bash-sanjianke/","title":"Bash 三剑客"},{"content":"Clojure中的数据类型详解 Clojure作为一门函数式编程语言，提供了一组丰富的数据类型。下面我将详细介绍Clojure中的核心数据类型及其特性。\n基本数据类型 数值(Number)类型 1 2 3 4 5 42 ; 整数 3.14 ; 浮点数 1/3 ; 分数(Ratio) 0xff ; 十六进制 2r1010 ; 二进制 原子(Atom)类型 1 2 3 4 :keyword ; 关键字(常作为键使用) \u0026#39;symbol ; 符号(表示标识符) true ; 布尔值 nil ; 空值 集合数据类型 字符串(String) 1 2 \u0026#34;Hello, Clojure!\u0026#34; ; 双引号包裹 \\A ; 单个字符(Java char) Clojure字符串就是Java字符串，支持多行：\n1 2 \u0026#34;第一行 第二行\u0026#34; 列表(List) - 不可变链表 1 2 \u0026#39;(1 2 3 4) ; 使用单引号 (list 1 2 3 4) ; 使用list函数 链表结构，头部插入高效 不可变 常用作函数调用形式或者数据序列 向量(Vector) - 不可变数组 1 2 [1 2 3 4] ; 方括号表示 (vector 1 2 3 4) ; 使用vector函数 基于数组，随机访问高效(O(1)) 不可变 常用作有序集合存储 集合(Set) - 不可变无序不重复集合 1 2 3 #{1 2 3 4} ; 花括号前加# (hash-set 1 2 3) ; 使用hash-set函数 (sorted-set 4 2) ; 排序集合→ #{2 4} 保证元素唯一 查找速度快(O(1)) 无序存储 字典(Map) - 键值对集合 1 2 3 {:name \u0026#34;Alice\u0026#34; :age 30} ; 花括号表示 (hash-map :a 1 :b 2) ; 使用hash-map函数 (sorted-map :b 2 :a 1) ; 排序Map→ {:a 1 :b 2} 键通常是关键字(keyword) 键的唯一性保证 支持嵌套结构 特殊数据类型 记录(Record) 1 2 3 (defrecord Person [name age]) (def alice (-\u0026gt;Person \u0026#34;Alice\u0026#34; 30)) (:name alice) ; 访问字段→ \u0026#34;Alice\u0026#34; 类似结构体 固定字段集合 实现Map接口 数组(Array) 1 2 (make-array Integer 3) ; Java数组 (int-array [1 2 3]) ; 基本类型数组 实际上是Java数组的包装 可变(mutable) 主要用于Java互操作 Clojure强调不可变数据，所有内置集合类型默认都是不可变的。要使用可变状态，需要显式使用atom、ref等引用类型来包装这些不可变数据结构。\nClojure基础语法：变量定义 Clojure作为一门Lisp方言的函数式编程语言，其变量定义方式与主流命令式语言有很大不同。以下是Clojure中主要的变量定义方式：\ndef - 定义全局变量 def用于定义全局命名空间内的变量：\n1 2 3 (def PI 3.14159) ;; 定义一个常量 (def company-name \u0026#34;TechCorp\u0026#34;) ;; 定义字符串变量 (def primes [2 3 5 7 11]) ;; 定义集合 注意：\ndef定义的变量是全局可访问的 虽然技术上可以修改(使用alter-var-root)，但惯例上应视为不可变 命名通常使用连字符，如user-name而非userName let - 定义局部绑定 let用于创建局部作用域的临时绑定：\n1 2 3 (let [radius 5 pi 3.14159] (* pi (* radius radius))) ;; 计算圆面积 特点：\n绑定只在let块内有效 绑定是并行赋值的(后面表达式不能依赖前面) 常用在函数内部定义临时变量 defn - 定义函数 虽然主要是定义函数，但也是一种变量绑定方式：\n1 2 3 4 5 (defn greet [name] (str \u0026#34;Hello, \u0026#34; name \u0026#34;!\u0026#34;)) ;; 等价于： (def greet (fn [name] (str \u0026#34;Hello, \u0026#34; name \u0026#34;!\u0026#34;))) 动态变量 (带星号) Clojure支持动态作用域变量：\n1 2 3 4 (def ^:dynamic *debug* false) (binding [*debug* true] (println \u0026#34;Debug mode:\u0026#34; *debug*)) 惯例：\n动态变量名称用*包围，如*out* 使用binding建立新的动态绑定 重要原则 不可变性：Clojure中的变量一旦定义，其值不应改变 避免全局状态：尽量使用局部绑定而非全局变量 线程安全：得益于不可变性，Clojure变量天生线程安全 这些是Clojure变量系统的基础部分，体现了其函数式编程的核心思想。\nClojure函数定义简介 Clojure作为一门函数式编程语言，函数是它的核心构建块。下面介绍Clojure中定义函数的主要方式：\n基本函数定义(defn) 使用defn宏定义命名函数：\n1 2 3 4 5 (defn function-name \u0026#34;可选的文档字符串\u0026#34; [param1 param2] ; 参数向量 (println param1 param2) ; 函数体 (+ param1 param2)) ; 隐式返回最后一个表达式 匿名函数(fn) 定义不绑定名称的函数：\n1 2 (fn [x y] (+ x y)) 或使用简写形式：\n1 #(+ %1 %2) ; %1表示第一个参数，%2表示第二个 多参数函数 Clojure支持可变参数：\n1 2 (defn sum [\u0026amp; nums] ; nums是序列 (apply + nums)) 多分派函数(defmulti/defmethod) 基于参数值选择不同实现：\n1 2 3 4 (defmulti greet :language) ; 根据:language分派 (defmethod greet :english [_] \u0026#34;Hello!\u0026#34;) (defmethod greet :spanish [_] \u0026#34;¡Hola!\u0026#34;) 高阶函数 函数可以作为参数或返回值：\n1 2 3 4 (defn apply-twice [f x] (f (f x))) (apply-twice #(* % 2) 3) ; 返回12 Clojure的函数是不可变的一等公民，这种设计支持函数组合和复用，是函数式编程的基础。\nClojure 函数重载与多参数处理综合指南 Clojure 提供了多种方式来实现类似其他语言中的函数重载功能，包括基于参数数量、类型和任意条件的分派方法。以下是综合介绍：\n基础函数多态（Multiple Arities） 最简单直接的\u0026quot;重载\u0026quot;方式是利用 Clojure 的函数多参数定义：\n1 2 3 4 5 6 7 8 9 10 11 12 (defn process \u0026#34;基础多参数实现\u0026#34; ([] (println \u0026#34;无参数调用\u0026#34;)) ([x] (println \u0026#34;单参数:\u0026#34; x)) ([x y] (println \u0026#34;双参数:\u0026#34; x y)) ([x y \u0026amp; z] (println \u0026#34;变长参数:\u0026#34; x y z))) ;; 使用示例 (process) ; 无参数调用 (process 10) ; 单参数: 10 (process 10 20) ; 双参数: 10 20 (process 1 2 3 4) ; 变长参数: 1 2 (3 4) 特点：\n最简洁的实现方式 编译时确定调用版本 性能最优 多重方法（Multimethods） 基于参数数量的分派 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 (defmulti handle-request \u0026#34;基于参数数量分派\u0026#34; (fn [\u0026amp; args] (count args))) (defmethod handle-request 0 [_] \u0026#34;处理无参数请求\u0026#34;) (defmethod handle-request 1 [[x]] (str \u0026#34;处理单请求: \u0026#34; x)) (defmethod handle-request 2 [[x y]] (str \u0026#34;处理双请求: \u0026#34; x \u0026#34;和\u0026#34; y)) (defmethod handle-request :default [args] (str \u0026#34;处理复杂请求: \u0026#34; (pr-str args))) 基于参数类型的分派 1 2 3 4 5 6 7 8 9 10 11 12 (defmulti calculate \u0026#34;基于参数类型分派\u0026#34; (fn [x y] [(class x) (class y)])) (defmethod calculate [Number Number] [x y] (+ x y)) (defmethod calculate [String String] [x y] (str x y)) (defmethod calculate [Number String] [x y] (str x y)) 层级分派（Hierarchical Dispatch） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 (defmulti render (fn [shape] (:type shape))) ;; 定义类型层次关系 (derive ::circle ::shape) (derive ::square ::shape) (defmethod render ::circle [_] \u0026#34;绘制圆形\u0026#34;) (defmethod render ::square [_] \u0026#34;绘制方形\u0026#34;) (defmethod render ::shape [_] \u0026#34;默认形状绘制\u0026#34;) 协议与记录（Protocols \u0026amp; Records） 适用于面向对象风格的重载：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 (defprotocol DataProcessor (process-data [this]) (process-data [this input]) (process-data [this input options])) (defrecord DefaultProcessor [] DataProcessor (process-data [this] \u0026#34;无参数处理\u0026#34;) (process-data [this input] (str \u0026#34;处理输入: \u0026#34; input)) (process-data [this input options] (str \u0026#34;处理输入 \u0026#34; input \u0026#34; 带选项 \u0026#34; options))) (let [p (DefaultProcessor.)] [(process-data p) (process-data p \u0026#34;data\u0026#34;) (process-data p \u0026#34;data\u0026#34; {:format :json})]) 综合使用示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 ;; 定义形状协议 (defprotocol Shape (area [this]) (perimeter [this])) ;; 实现圆形 (defrecord Circle [radius] Shape (area [this] (* Math/PI radius radius)) (perimeter [this] (* 2 Math/PI radius))) ;; 实现矩形 - 使用多参数构造 (defn make-rectangle ([side] (make-rectangle side side)) ; 正方形 ([width height] (Rectangle. width height))) (defrecord Rectangle [width height] Shape (area [this] (* width height)) (perimeter [this] (* 2 (+ width height)))) ;; 定义针对形状的多重方法 (defmulti draw :type) (defmethod draw :circle [{r :radius}] (str \u0026#34;绘制圆形，半径 \u0026#34; r)) (defmethod draw :rectangle [{w :width h :height}] (str \u0026#34;绘制矩形 \u0026#34; w \u0026#34;x\u0026#34; h)) 选择指南 特性 多参数函数 多重方法 协议 参数数量分派 ✓ ✓ ✓ 参数类型分派 ✗ ✓ ✓ 自定义条件分派 ✗ ✓ ✗ 性能 最优 中等 高 扩展性 有限 强 中等 代码组织 简单 灵活 结构化 推荐选择：\n优先使用简单的多参数函数实现基础重载 需要复杂分派逻辑时使用多重方法 定义数据类型行为时使用协议 Clojure 的这些特性共同构成了比传统面向对象语言更灵活的多态系统，开发者可以根据具体需求选择最合适的实现方式。\nClojure宏：代码的代码 Clojure宏(Macro)是一种元编程工具，允许你在编译时对代码进行转换，而不是在运行时处理数据。宏是Lisp家族语言最强大的特性之一，让语言具有真正的可扩展性。\n宏的基本概念 宏与普通函数的关键区别：\n执行时机：函数在运行时执行，宏在编译时展开 参数处理：函数会先对参数求值，宏接收未求值的表达式 定义宏 使用defmacro定义宏：\n1 2 3 (defmacro macro-name [params] ; 返回可以求值的表达式 ) 简单宏示例 unless宏 1 2 3 4 5 6 7 8 (defmacro unless [condition \u0026amp; body] `(if (not ~condition) (do ~@body))) ; 使用 (unless (= 2 (+ 1 1)) (println \u0026#34;Math is broken!\u0026#34;) (println \u0026#34;This should never print\u0026#34;)) 这个宏实现了与if not相反的逻辑，展开后变为：\n1 2 3 4 (if (not (= 2 (+ 1 1))) (do (println \u0026#34;Math is broken!\u0026#34;) (println \u0026#34;This should never print\u0026#34;))) infix宏 1 2 3 4 5 6 7 (defmacro infix [form] (list (second form) (first form) (nth form 2))) ; 使用 (infix (2 + 3)) ; =\u0026gt; 5 这个宏允许使用中缀表示法（如2 + 3）进行数学运算。\n高级宏技术 语法引号与解引 在宏中常用反引号(`)创建模板，使用~解引用符号：\n1 2 3 4 (defmacro debug [expr] `(let [result# ~expr] (println \u0026#34;Debug:\u0026#34; \u0026#39;~expr \u0026#34;=\u0026gt;\u0026#34; result#) result#)) result#会自动生成唯一的符号名，避免名称冲突。\n使用macroexpand理解宏 1 2 (macroexpand \u0026#39;(unless true (println \u0026#34;No\u0026#34;))) ; 输出：(if (clojure.core/not true) (do (println \u0026#34;No\u0026#34;))) 实际应用案例 性能计时宏 1 2 3 4 5 6 7 8 (defmacro time-exec \u0026#34;执行表达式并返回执行时间和结果\u0026#34; [expr] `(let [start# (System/currentTimeMillis) result# ~expr end# (System/currentTimeMillis)] {:result result# :time (- end# start#)})) 领域特定语言(DSL) 宏可以创建自定义语法：\n1 2 3 4 5 6 7 (defmacro define-route [method path args \u0026amp; body] `(defroutes ~(symbol (str method \u0026#34;-\u0026#34; (name path))) (~method ~path ~args (do ~@body)))) (define-route GET \u0026#34;/user/:id\u0026#34; [id] (str \u0026#34;User ID: \u0026#34; id)) 宏的最佳实践 优先使用函数：能用函数解决的不要用宏 保持简单：宏应该聚焦在语法转换上 避免意外捕获变量：使用自动生成的符号名(如var#) 文档齐全：宏比函数更难理解，需要更好的文档 总结 Clojure宏提供了一种强大的代码生成机制，允许你扩展语言本身。虽然强大，但也需要谨慎使用。理解宏的关键是记住它们在编译阶段处理代码，而不是在运行时处理数据。\n通过合理使用宏，可以消除重复代码、创建领域特定语言，以及实现超出核心语言语法的功能。\n","date":"2022-03-06T00:00:00Z","image":"//localhost:1313/p/clojure-basic-var-and-fun/clojure-basic-a-cover_hu_a57c751c972cbad7.png","permalink":"//localhost:1313/p/clojure-basic-var-and-fun/","title":"Clojure 基础语法 —— 变量和函数"},{"content":"Python变量的基本概念 在Python中，变量是用来存储数据的“标签”或“名字”，它指向内存中的某个对象 (◕‿◕✿)\n核心特点： 无需声明类型（动态类型语言） 通过赋值自动创建变量 变量本身没有类型，它指向的对象有类型 比如：\n1 2 3 4 x = 42 # 整数 name = \u0026#34;DeepSeek\u0026#34; # 字符串 pi = 3.14 # 浮点数 is_cool = True # 布尔值 变量的命名规则 Python变量命名需遵守以下规则 (•̀ᴗ•́)و：\n合法字符：字母、数字、下划线（但不能以数字开头）\n正确：user_name, total_count2 错误：2nd_place（数字开头）、user-name（含连字符） 区分大小写：\n1 2 age = 20 Age = 30 # 这是另一个变量！ 避免关键字：\n不能使用if、for、while等Python保留字 (╯°□°)╯︵ ┻━┻\n1 class = \u0026#34;CS101\u0026#34; # 语法错误！ 风格建议（PEP 8）：\n变量名推荐小写 + 下划线（snake_case）：student_name 常量全大写：MAX_SIZE = 100 变量赋值机制 Python的变量是对象的引用，而非存储数据的容器 (ﾉ◕ヮ◕)ﾉ*:･ﾟ✧\n示例：\n1 2 3 4 a = 10 b = a # b也指向10这个对象 a = 20 # 现在a指向新对象20，b仍指向10 print(b) # 输出：10 多重赋值：\n1 2 x, y, z = 1, \u0026#34;hello\u0026#34;, True # 同时赋值多个变量 x = y = z = 0 # 所有变量指向同一个对象 变量类型推断 虽然不需要声明类型，但对象有明确类型 (๑•̀ㅂ•́)و✧：\n1 2 3 num = 42 # \u0026lt;class \u0026#39;int\u0026#39;\u0026gt; text = \u0026#34;DeepSeek\u0026#34; # \u0026lt;class \u0026#39;str\u0026#39;\u0026gt; lst = [1, 2, 3] # \u0026lt;class \u0026#39;list\u0026#39;\u0026gt; 可以用type()函数检查类型：\n1 print(type(num)) # 输出：\u0026lt;class \u0026#39;int\u0026#39;\u0026gt; 特殊变量 删除变量：用del释放引用\n1 2 3 temp = 100 del temp # 移除变量名 print(temp) # 报错：NameError 动态类型：变量可随时指向不同类型\n1 2 stuff = 42 # 现在是int stuff = \u0026#34;答案\u0026#34; # 瞬间变成str 作用域规则 变量的“可见范围”由其定义位置决定 (ﾉ´ヮ`)ﾉ*: ･ﾟ\n局部变量：函数内定义，仅在函数内有效 全局变量：模块级定义，全局可访问（但函数内修改需声明global） 示例：\n1 2 3 4 5 6 7 8 9 10 global_var = \u0026#34;我是全局的\u0026#34; def test(): local_var = \u0026#34;我是局部的\u0026#34; print(global_var) # 可以访问全局变量 global new_var # 声明为全局变量 new_var = 100 test() print(local_var) # 报错：local_var未定义 总结 总结一下 (￣^￣)ゞ：\nPython变量是名字到对象的绑定 命名要合法且风格统一 类型灵活但需注意作用域 试着玩转变量吧～ ヾ(≧▽≦*)o\n","date":"2022-03-06T00:00:00Z","image":"//localhost:1313/p/program-python-basic-01-variable/cover_hu_857d88d6b0a3b5cd.jpeg","permalink":"//localhost:1313/p/program-python-basic-01-variable/","title":"Python Basic 01 变量定义"},{"content":"函数定义基础概念 (◕‿◕✿) 函数是Python中可复用的代码块，通过def关键字定义：\n1 2 3 4 def 函数名(参数列表): \u0026#34;\u0026#34;\u0026#34;文档字符串（可选）\u0026#34;\u0026#34;\u0026#34; 函数体 return 返回值 # 可选 命名规则：推荐使用snake_case，如calculate_average() 参数：支持位置参数、默认参数等（后面会展开讲哦~） 返回值：用return返回，若无return语句则返回None 举个栗子 🌰：\n1 2 3 4 def greet(name): \u0026#34;\u0026#34;\u0026#34;输出个性化问候\u0026#34;\u0026#34;\u0026#34; print(f\u0026#34;Hello, {name}! (ﾉ◕ヮ◕)ﾉ*:･ﾟ✧\u0026#34;) return len(name) # 返回名字长度 参数传递机制 不可变对象 vs 可变对象 不可变对象（数字/字符串/元组）：传值（副本） 1 2 3 4 def modify_num(x): x += 10 # 不影响外部变量 n = 5 modify_num(n) # n仍是5 可变对象（列表/字典）：传引用（原地修改） 1 2 3 4 def append_item(lst): lst.append(\u0026#34;🎉\u0026#34;) my_list = [1, 2] append_item(my_list) # my_list变为[1, 2, \u0026#34;🎉\u0026#34;] 参数类型大全 参数类型 语法示例 说明 位置参数 func(a, b) 按顺序传参 关键字参数 func(b=2, a=1) 指定参数名传参 默认参数 def func(a=0) 参数默认值 可变位置参数 def func(*args) 接收元组 args=(1,2,3) 可变关键字参数 def func(**kwargs) 接收字典 kwargs={\u0026quot;x\u0026quot;:1} 举个混合参数的例子 🌈：\n1 2 3 4 5 def mixed_params(a, b=2, *args, **kwargs): print(f\u0026#34;a={a}, b={b}, args={args}, kwargs={kwargs}\u0026#34;) mixed_params(1, 3, 4, 5, key=\u0026#34;value\u0026#34;) # 输出: a=1, b=3, args=(4, 5), kwargs={\u0026#39;key\u0026#39;: \u0026#39;value\u0026#39;} 高阶函数特性 函数作为对象 函数是一等公民，可以被赋值/传递 (•̀ᴗ•́)و\n1 2 3 4 5 def square(x): return x ** 2 func_obj = square # 函数赋值 print(func_obj(3)) # 输出9 嵌套函数与闭包 嵌套函数：函数内部定义函数 1 2 3 4 def outer(): def inner(): print(\u0026#34;我是套娃函数！(≧∇≦)ﾉ\u0026#34;) return inner() 闭包：携带外部作用域的变量 1 2 3 4 5 6 7 def power_factory(exp): def power(base): return base ** exp # 记住exp的值 return power square = power_factory(2) # 专用平方函数 print(square(3)) # 输出9 装饰器（核心知识点！✨） 装饰器本质是高阶函数，用于增强函数功能：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 def debug_decorator(func): def wrapper(*args, **kwargs): print(f\u0026#34;⚡️ 调用 {func.__name__}()\u0026#34;) return func(*args, **kwargs) return wrapper @debug_decorator # 语法糖 def say_hello(): print(\u0026#34;Hello World!\u0026#34;) say_hello() # 输出: # ⚡️ 调用 say_hello() # Hello World! 函数注解（Type Hints） Python 3.5+ 支持类型提示，用-\u0026gt;指定返回类型：\n1 2 3 def add(a: int, b: int) -\u0026gt; int: \u0026#34;\u0026#34;\u0026#34;两数相加\u0026#34;\u0026#34;\u0026#34; return a + b 优点：提升代码可读性，IDE能智能提示 注意：不会强制类型检查（需配合mypy等工具） 希望这份指南能帮你掌握Python函数精髓！(๑•̀ㅂ•́)و✧ 有疑问随时提问~\n","date":"2022-03-06T00:00:00Z","image":"//localhost:1313/p/program-python-basic-02-function/prog-python-02-function-cover_hu_857d88d6b0a3b5cd.jpeg","permalink":"//localhost:1313/p/program-python-basic-02-function/","title":"Python Basic 02 函数定义"},{"content":"Python分支结构概述 (๑•̀ㅂ•́)و✧ Python中的分支结构主要通过条件语句实现，它能让程序根据不同的条件选择性地执行代码块。在Python中，主要使用if、elif和else关键字来构建分支逻辑，就像人生中的选择题一样，程序会根据条件判断选择不同的道路前进呢！(◕‿◕✿)\n基本分支结构 最简单的if语句 1 2 if 条件表达式: # 条件为True时执行的代码块 示例：\n1 2 3 x = 10 if x \u0026gt; 5: print(\u0026#34;x大于5呢！\u0026#34;) # 这个会被执行 ╰(*°▽°*)╯ if-else结构 当需要处理两种情况时：\n1 2 3 4 if 条件表达式: # 条件为True时执行的代码 else: # 条件为False时执行的代码 示例：\n1 2 3 4 5 age = 17 if age \u0026gt;= 18: print(\u0026#34;成年啦！可以进入~\u0026#34;) else: print(\u0026#34;抱歉，未成年不能进入哦 (；′⌒`)\u0026#34;) if-elif-else结构 当有多种可能性时：\n1 2 3 4 5 6 7 if 条件1: # 满足条件1时执行 elif 条件2: # 满足条件2时执行 ... else: # 其他情况执行 示例：\n1 2 3 4 5 6 7 8 9 score = 85 if score \u0026gt;= 90: print(\u0026#34;优秀！٩(๑❛ᴗ❛๑)۶\u0026#34;) elif score \u0026gt;= 75: print(\u0026#34;良好~ (￣▽￣)~*\u0026#34;) elif score \u0026gt;= 60: print(\u0026#34;及格... 再接再厉！\u0026#34;) else: print(\u0026#34;不及格啊啊啊 (ﾟДﾟ*)ﾉ\u0026#34;) 嵌套分支结构 有时候需要在条件分支中再嵌套条件判断：\n1 2 3 4 5 6 7 if 外层条件: if 内层条件: # 代码块 else: # 代码块 else: # 代码块 示例：\n1 2 3 4 5 6 7 8 9 num = 15 if num \u0026gt; 10: print(\u0026#34;大于10\u0026#34;) if num % 2 == 0: print(\u0026#34;而且是偶数呢！\u0026#34;) else: print(\u0026#34;但是是奇数哟~\u0026#34;) else: print(\u0026#34;不大于10 (╯︵╰,)\u0026#34;) 条件表达式 在Python中可以使用条件表达式（类似其他语言的三目运算符）：\n1 值1 if 条件 else 值2 示例：\n1 2 3 x = 10 y = 20 max_val = x if x \u0026gt; y else y # 获取较大值 布尔运算与分支 可以使用逻辑运算符组合多个条件：\nand：与 or：或 not：非 示例：\n1 2 3 4 age = 22 height = 175 if age \u0026gt;= 18 and height \u0026gt;= 170: print(\u0026#34;符合参军条件！(•̀ᴗ•́)و\u0026#34;) 特殊值判断 在Python中，一些特殊值会被视为False：\nFalse None 数值0 空序列：\u0026quot;\u0026quot;、[]、() 空映射：{} 可以利用这个特性简化判断：\n1 2 3 name = \u0026#34;\u0026#34; if not name: print(\u0026#34;名字为空哦！(⊙ˍ⊙)\u0026#34;) 使用技巧与小贴士 代码风格：Python依赖缩进，一定要保持一致的缩进（通常4个空格） 执行效率：条件判断会从上到下依次执行，将最可能满足的条件放在前面可以提高效率 比较运算符： ==：等于 !=：不等于 \u0026gt;、\u0026lt;、\u0026gt;=、\u0026lt;=：大小比较 is：判断对象是否相同（比较内存地址） in：判断元素是否在序列中 示例：\n1 2 3 colors = [\u0026#34;red\u0026#34;, \u0026#34;green\u0026#34;, \u0026#34;blue\u0026#34;] if \u0026#34;green\u0026#34; in colors: print(\u0026#34;找到绿色啦！(★ω★)\u0026#34;) 实际应用小案例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 # 简单的计算器 print(\u0026#34;简易计算器启动~ (=´ω｀=)\u0026#34;) num1 = float(input(\u0026#34;请输入第一个数字：\u0026#34;)) operator = input(\u0026#34;请输入运算符(+ - * /)：\u0026#34;) num2 = float(input(\u0026#34;请输入第二个数字：\u0026#34;)) if operator == \u0026#34;+\u0026#34;: result = num1 + num2 elif operator == \u0026#34;-\u0026#34;: result = num1 - num2 elif operator == \u0026#34;*\u0026#34;: result = num1 * num2 elif operator == \u0026#34;/\u0026#34;: if num2 != 0: result = num1 / num2 else: result = \u0026#34;错误：除数不能为0！(╯‵□′)╯︵┻━┻\u0026#34; else: result = \u0026#34;错误：无效的运算符！Σ( ° △ °|||)︴\u0026#34; print(f\u0026#34;计算结果：{result}\u0026#34;) 分支结构是Python编程的基础呢！熟练掌握它们可以让你的程序更加\u0026quot;聪明\u0026quot;和灵活 (๑•̀ㅂ•́)و✧ 记住多多练习不同的分支场景，遇到问题随时问我哦~ (づ￣3￣)づ╭❤～\n","date":"2022-03-06T00:00:00Z","image":"//localhost:1313/p/program-python-basic-03-if/prog-python-03-if-cover_hu_857d88d6b0a3b5cd.jpeg","permalink":"//localhost:1313/p/program-python-basic-03-if/","title":"Python Basic 03 分支语句"},{"content":"循环的基本概念 在编程中，循环(Loop) 是重复执行某段代码的控制结构。主要有两种类型：\n确定循环：明确知道循环次数 (如for循环) 不确定循环：根据条件判断是否继续循环 (如while循环) 循环结构是我们处理重复性工作的利器呢 (ง •_•)ง\nfor循环详解 基本语法 1 2 for 临时变量 in 可迭代对象: # 循环体 这里的可迭代对象可以是：\n序列类型：字符串、列表、元组 字典(遍历键) range对象 文件对象等 range函数使用 生成整数序列的神器 ✨\n1 2 3 range(stop) # 0到stop-1 range(start, stop) # start到stop-1 range(start, stop, step) # 自定义步长 经典应用场景 1 2 3 4 5 # 计算1到100的和 (๑•̀ㅂ•́)و✧ total = 0 for num in range(1, 101): total += num print(f\u0026#34;1到100的和是: {total}\u0026#34;) while循环深入 基本语法 1 2 while 条件表达式: # 循环体 注意事项 ⚠️ 一定要确保循环条件最终能变为False，否则会进入无限循环！\n1 2 3 4 5 # 安全示例 count = 0 while count \u0026lt; 5: print(f\u0026#34;当前计数: {count}\u0026#34;) count += 1 # 千万别忘了这行！(ノಠ益ಠ)ノ 循环控制语句 break语句 立即终止当前循环 (╯°□°)╯\n1 2 3 4 for num in range(10): if num == 5: break print(num) # 只打印0-4 continue语句 跳过当前迭代，进入下一次 (￣▽￣*)ゞ\n1 2 3 4 for num in range(10): if num % 2 == 0: continue print(num) # 只打印奇数 else子句 循环正常结束(非break终止)时执行 (。-`ω´-)\n1 2 3 4 for num in range(3): print(num) else: print(\u0026#34;循环正常结束啦~\u0026#34;) 嵌套循环 循环套循环，解决多维问题 ヽ(✿ﾟ▽ﾟ)ノ\n1 2 3 4 5 # 打印九九乘法表 for i in range(1, 10): for j in range(1, i+1): print(f\u0026#34;{j}×{i}={i*j}\u0026#34;, end=\u0026#34;\\t\u0026#34;) print() # 换行 循环优化技巧 列表推导式 简洁优雅的循环替代方案 ✨\n1 squares = [x**2 for x in range(10)] # 生成平方数列表 使用enumerate 同时获取索引和值 (￣ω￣)\n1 2 3 fruits = [\u0026#39;apple\u0026#39;, \u0026#39;banana\u0026#39;, \u0026#39;cherry\u0026#39;] for index, fruit in enumerate(fruits): print(f\u0026#34;索引 {index} 是 {fruit}\u0026#34;) 使用zip 并行迭代多个序列 ٩(◕‿◕｡)۶\n1 2 3 4 names = [\u0026#39;Alice\u0026#39;, \u0026#39;Bob\u0026#39;, \u0026#39;Charlie\u0026#39;] ages = [24, 30, 22] for name, age in zip(names, ages): print(f\u0026#34;{name} is {age} years old\u0026#34;) 性能考量 在科研计算中，循环性能很重要哦！(｀・ω・´)\n避免在循环内做重复计算 对于大数据处理，考虑使用NumPy的矢量化操作 必要时使用内置函数(map, filter等)替代显式循环 ","date":"2022-03-06T00:00:00Z","image":"//localhost:1313/p/program-python-basic-04-for/prog-python-04-for-cover_hu_857d88d6b0a3b5cd.jpeg","permalink":"//localhost:1313/p/program-python-basic-04-for/","title":"Python Basic 04 循环语句"},{"content":"创建字符串 (★ω★) 1 2 3 4 5 6 # 三种引号创建字符串 str1 = \u0026#39;单引号字符串\u0026#39; str2 = \u0026#34;双引号字符串\u0026#34; str3 = \u0026#39;\u0026#39;\u0026#39;三引号可以 跨行 的字符串\u0026#39;\u0026#39;\u0026#39; 基础操作 (*￣▽￣)b 1 2 3 4 5 6 7 8 9 10 11 12 13 s = \u0026#34;Hello Python\u0026#34; # 字符串长度 len(s) # 12 # 索引访问 s[0] # \u0026#39;H\u0026#39; (第一个字符) s[-1] # \u0026#39;n\u0026#39; (最后一个字符)s # 切片操作 s[0:5] # \u0026#39;Hello\u0026#39; (第0到4个字符) s[6:] # \u0026#39;Python\u0026#39; (第6个到末尾) s[::2] # \u0026#39;HloPto\u0026#39; (每隔一个字符) 字符串常用方法 ヾ(^▽^*))) 修改字符串 1 2 3 4 5 6 7 8 9 10 11 12 13 # 转换大小写 \u0026#34;hello\u0026#34;.upper() # \u0026#39;HELLO\u0026#39; \u0026#34;HELLO\u0026#34;.lower() # \u0026#39;hello\u0026#39; \u0026#34;hello world\u0026#34;.title() # \u0026#39;Hello World\u0026#39; \u0026#34;hello world\u0026#34;.capitalize() # \u0026#39;Hello world\u0026#39; # 替换 \u0026#34;hello\u0026#34;.replace(\u0026#39;l\u0026#39;, \u0026#39;L\u0026#39;) # \u0026#39;heLLo\u0026#39; # 去除空白 \u0026#34; hello \u0026#34;.strip() # \u0026#39;hello\u0026#39; \u0026#34; hello \u0026#34;.lstrip() # \u0026#39;hello \u0026#39; \u0026#34; hello \u0026#34;.rstrip() # \u0026#39; hello\u0026#39; 拼接与分割 (ﾉ◕ヮ◕)ﾉ*:･ﾟ✧ 1 2 3 4 5 6 7 8 # 拼接 \u0026#34;, \u0026#34;.join([\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;orange\u0026#34;]) # \u0026#39;apple, banana, orange\u0026#39; # 分割 \u0026#34;apple,banana,orange\u0026#34;.split(\u0026#34;,\u0026#34;) # [\u0026#39;apple\u0026#39;, \u0026#39;banana\u0026#39;, \u0026#39;orange\u0026#39;] # 按行分割 \u0026#34;line1\\nline2\\nline3\u0026#34;.splitlines() # [\u0026#39;line1\u0026#39;, \u0026#39;line2\u0026#39;, \u0026#39;line3\u0026#39;] 查找与判断 (=￣ω￣=) 1 2 3 4 5 6 7 8 9 10 11 # 查找位置 \u0026#34;hello\u0026#34;.find(\u0026#39;l\u0026#39;) # 2 (第一个\u0026#39;l\u0026#39;的位置) \u0026#34;hello\u0026#34;.rfind(\u0026#39;l\u0026#39;) # 3 (最后一个\u0026#39;l\u0026#39;的位置) \u0026#34;hello\u0026#34;.index(\u0026#39;e\u0026#39;) # 1 (类似于find但如果找不到会报错) # 判断内容 \u0026#34;123\u0026#34;.isdigit() # True (全是数字) \u0026#34;abc\u0026#34;.isalpha() # True (全是字母) \u0026#34;abc123\u0026#34;.isalnum() # True (字母或数字) \u0026#34;hello\u0026#34;.startswith(\u0026#39;he\u0026#39;) # True \u0026#34;hello\u0026#34;.endswith(\u0026#39;lo\u0026#39;) # True 格式化字符串 (｀・ω・´) 1 2 3 4 5 6 7 8 9 10 11 12 # 1. % 格式化 (老方法) \u0026#34;Hello, %s!\u0026#34; % \u0026#34;World\u0026#34; # \u0026#39;Hello, World!\u0026#39; \u0026#34;%d + %d = %d\u0026#34; % (1, 2, 1+2) # \u0026#39;1 + 2 = 3\u0026#39; # 2. format方法 \u0026#34;Hello, {}!\u0026#34;.format(\u0026#34;World\u0026#34;) # \u0026#39;Hello, World!\u0026#39; \u0026#34;{1} {0} {1}\u0026#34;.format(\u0026#34;world\u0026#34;, \u0026#34;hello\u0026#34;) # \u0026#39;hello world hello\u0026#39; # 3. f-string (Python 3.6+) name = \u0026#34;Alice\u0026#34; age = 25 f\u0026#34;My name is {name} and I\u0026#39;m {age} years old.\u0026#34; 转义字符 (⊙ˍ⊙) 1 2 3 4 print(\u0026#34;换行\\n制表符\\t双引号\\\u0026#34;单引号\\\u0026#39;反斜杠\\\\\u0026#34;) # 输出: # 换行 # 制表符 双引号\u0026#34;单引号\u0026#39;反斜杠\\ 其他有用操作 ٩(◕‿◕｡)۶ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 # 字符串重复 \u0026#34;Hi\u0026#34; * 3 # \u0026#39;HiHiHi\u0026#39; # 对齐 \u0026#34;hello\u0026#34;.ljust(10) # \u0026#39;hello \u0026#39; \u0026#34;hello\u0026#34;.rjust(10) # \u0026#39; hello\u0026#39; \u0026#34;hello\u0026#34;.center(10) # \u0026#39; hello \u0026#39; # 计数 \u0026#34;hello hello\u0026#34;.count(\u0026#39;l\u0026#39;) # 4 (统计\u0026#39;l\u0026#39;出现的次数) # 判断空白字符 \u0026#34; \u0026#34;.isspace() # True # 反转字符串 s = \u0026#34;Python\u0026#34; s[::-1] # \u0026#39;nohtyP\u0026#39; # 多条件分割 import re re.split(r\u0026#39;[,;|\\s]\\s*\u0026#39;, \u0026#34;one,two;three|four five\u0026#34;) # [\u0026#39;one\u0026#39;, \u0026#39;two\u0026#39;, \u0026#39;three\u0026#39;, \u0026#39;four\u0026#39;, \u0026#39;five\u0026#39;] 总结 字符串操作真的是Python编程中最常用的技能之一呢！(ﾉ≧∀≦)ﾉ 多加练习才能熟练掌握哦！(•̀ᴗ•́)و ̑̑\n","date":"2022-03-06T00:00:00Z","image":"//localhost:1313/p/program-python-basic-05-string/prog-python-05-string_hu_857d88d6b0a3b5cd.jpeg","permalink":"//localhost:1313/p/program-python-basic-05-string/","title":"Python Basic 05 字符串处理"},{"content":"创建字符串 (★ω★) 1 2 3 4 5 6 # 三种引号创建字符串 str1 = \u0026#39;单引号字符串\u0026#39; str2 = \u0026#34;双引号字符串\u0026#34; str3 = \u0026#39;\u0026#39;\u0026#39;三引号可以 跨行 的字符串\u0026#39;\u0026#39;\u0026#39; 基础操作 (*￣▽￣)b 1 2 3 4 5 6 7 8 9 10 11 12 13 s = \u0026#34;Hello Python\u0026#34; # 字符串长度 len(s) # 12 # 索引访问 s[0] # \u0026#39;H\u0026#39; (第一个字符) s[-1] # \u0026#39;n\u0026#39; (最后一个字符)s # 切片操作 s[0:5] # \u0026#39;Hello\u0026#39; (第0到4个字符) s[6:] # \u0026#39;Python\u0026#39; (第6个到末尾) s[::2] # \u0026#39;HloPto\u0026#39; (每隔一个字符) 字符串常用方法 ヾ(^▽^*))) 修改字符串 1 2 3 4 5 6 7 8 9 10 11 12 13 # 转换大小写 \u0026#34;hello\u0026#34;.upper() # \u0026#39;HELLO\u0026#39; \u0026#34;HELLO\u0026#34;.lower() # \u0026#39;hello\u0026#39; \u0026#34;hello world\u0026#34;.title() # \u0026#39;Hello World\u0026#39; \u0026#34;hello world\u0026#34;.capitalize() # \u0026#39;Hello world\u0026#39; # 替换 \u0026#34;hello\u0026#34;.replace(\u0026#39;l\u0026#39;, \u0026#39;L\u0026#39;) # \u0026#39;heLLo\u0026#39; # 去除空白 \u0026#34; hello \u0026#34;.strip() # \u0026#39;hello\u0026#39; \u0026#34; hello \u0026#34;.lstrip() # \u0026#39;hello \u0026#39; \u0026#34; hello \u0026#34;.rstrip() # \u0026#39; hello\u0026#39; 拼接与分割 (ﾉ◕ヮ◕)ﾉ*:･ﾟ✧ 1 2 3 4 5 6 7 8 # 拼接 \u0026#34;, \u0026#34;.join([\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;orange\u0026#34;]) # \u0026#39;apple, banana, orange\u0026#39; # 分割 \u0026#34;apple,banana,orange\u0026#34;.split(\u0026#34;,\u0026#34;) # [\u0026#39;apple\u0026#39;, \u0026#39;banana\u0026#39;, \u0026#39;orange\u0026#39;] # 按行分割 \u0026#34;line1\\nline2\\nline3\u0026#34;.splitlines() # [\u0026#39;line1\u0026#39;, \u0026#39;line2\u0026#39;, \u0026#39;line3\u0026#39;] 查找与判断 (=￣ω￣=) 1 2 3 4 5 6 7 8 9 10 11 # 查找位置 \u0026#34;hello\u0026#34;.find(\u0026#39;l\u0026#39;) # 2 (第一个\u0026#39;l\u0026#39;的位置) \u0026#34;hello\u0026#34;.rfind(\u0026#39;l\u0026#39;) # 3 (最后一个\u0026#39;l\u0026#39;的位置) \u0026#34;hello\u0026#34;.index(\u0026#39;e\u0026#39;) # 1 (类似于find但如果找不到会报错) # 判断内容 \u0026#34;123\u0026#34;.isdigit() # True (全是数字) \u0026#34;abc\u0026#34;.isalpha() # True (全是字母) \u0026#34;abc123\u0026#34;.isalnum() # True (字母或数字) \u0026#34;hello\u0026#34;.startswith(\u0026#39;he\u0026#39;) # True \u0026#34;hello\u0026#34;.endswith(\u0026#39;lo\u0026#39;) # True 格式化字符串 (｀・ω・´) 1 2 3 4 5 6 7 8 9 10 11 12 # 1. % 格式化 (老方法) \u0026#34;Hello, %s!\u0026#34; % \u0026#34;World\u0026#34; # \u0026#39;Hello, World!\u0026#39; \u0026#34;%d + %d = %d\u0026#34; % (1, 2, 1+2) # \u0026#39;1 + 2 = 3\u0026#39; # 2. format方法 \u0026#34;Hello, {}!\u0026#34;.format(\u0026#34;World\u0026#34;) # \u0026#39;Hello, World!\u0026#39; \u0026#34;{1} {0} {1}\u0026#34;.format(\u0026#34;world\u0026#34;, \u0026#34;hello\u0026#34;) # \u0026#39;hello world hello\u0026#39; # 3. f-string (Python 3.6+) name = \u0026#34;Alice\u0026#34; age = 25 f\u0026#34;My name is {name} and I\u0026#39;m {age} years old.\u0026#34; 转义字符 (⊙ˍ⊙) 1 2 3 4 print(\u0026#34;换行\\n制表符\\t双引号\\\u0026#34;单引号\\\u0026#39;反斜杠\\\\\u0026#34;) # 输出: # 换行 # 制表符 双引号\u0026#34;单引号\u0026#39;反斜杠\\ 其他有用操作 ٩(◕‿◕｡)۶ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 # 字符串重复 \u0026#34;Hi\u0026#34; * 3 # \u0026#39;HiHiHi\u0026#39; # 对齐 \u0026#34;hello\u0026#34;.ljust(10) # \u0026#39;hello \u0026#39; \u0026#34;hello\u0026#34;.rjust(10) # \u0026#39; hello\u0026#39; \u0026#34;hello\u0026#34;.center(10) # \u0026#39; hello \u0026#39; # 计数 \u0026#34;hello hello\u0026#34;.count(\u0026#39;l\u0026#39;) # 4 (统计\u0026#39;l\u0026#39;出现的次数) # 判断空白字符 \u0026#34; \u0026#34;.isspace() # True # 反转字符串 s = \u0026#34;Python\u0026#34; s[::-1] # \u0026#39;nohtyP\u0026#39; # 多条件分割 import re re.split(r\u0026#39;[,;|\\s]\\s*\u0026#39;, \u0026#34;one,two;three|four five\u0026#34;) # [\u0026#39;one\u0026#39;, \u0026#39;two\u0026#39;, \u0026#39;three\u0026#39;, \u0026#39;four\u0026#39;, \u0026#39;five\u0026#39;] 总结 字符串操作真的是Python编程中最常用的技能之一呢！(ﾉ≧∀≦)ﾉ 多加练习才能熟练掌握哦！(•̀ᴗ•́)و ̑̑\n","date":"2022-03-06T00:00:00Z","image":"//localhost:1313/p/program-python-basic-06-list/prog-python-06-list_hu_857d88d6b0a3b5cd.jpeg","permalink":"//localhost:1313/p/program-python-basic-06-list/","title":"Python Basic 06 列表处理"},{"content":"罗马不列颠（43-410年） 征服过程：克劳迪乌斯动用4万军队，镇压凯尔特女王布狄卡起义（60年）。 基建遗产： 伦敦（Londinium）成为贸易中心，修建罗马式道路（如福斯路）。 巴斯温泉浴场体现罗马生活方式。 衰落原因：帝国收缩防御，北方皮克特人侵袭，409年罗马驻军撤离。 背景 公元前1世纪，不列颠岛屿主要由凯尔特部落（如爱西尼人、布里甘特人等）统治。罗马共和国曾于前55年、前54年两次入侵（尤利乌斯·恺撒率军），但未建立长期统治。\n征服与建立行省（43-84年） 43年：罗马皇帝克劳狄乌斯派军4万入侵不列颠，击败当地部落，建立行省\u0026quot;不列颠尼亚\u0026quot;（Britannia），首府初设科尔切斯特（Camulodunum）。 60年：爱西尼部落女王布狄卡（Boudica）起义，焚毁伦敦（Londinium）、科尔切斯特等城市，后被罗马镇压。 70-84年：罗马总督阿古利可拉（Agricola）向北部扩张，至84年基本控制今英格兰地区，并在苏格兰击败喀里多尼亚人（但未永久占领）。 罗马化与建设（2-3世纪） 城市发展：建立伦敦（商业中心）、约克（Eboracum，军事重镇）、巴斯（温泉疗养地）等城市，引入罗马式建筑（神庙、浴场、剧院）。 基础设施：修筑道路（如福斯路Fosse Way）、哈德良长城（122年建于英格兰北部，防御苏格兰部落）。 经济：开采锡、铅矿，发展农业（引入葡萄种植），与帝国其他行省贸易。 宗教：罗马多神教与本地信仰融合，后期基督教传入（约3世纪）。 危机与衰落（3-4世纪） 外患：撒克逊海盗袭扰东部海岸，皮克特人（苏格兰）、斯科特人（爱尔兰）进攻北部。 内乱：286年，海军将领卡劳修斯（Carausius）自立为不列颠皇帝，293年被镇压。 行政调整：4世纪，不列颠被分为4个行省，军事防御加强（如建造\u0026quot;撒克逊海岸堡垒\u0026quot;）。 罗马撤离（410年） 407年：将领君士坦丁三世带军队撤离不列颠，前往高卢争夺帝位。 410年：皇帝霍诺留发信告知不列颠人\u0026quot;自谋防御\u0026quot;，标志罗马统治正式结束。当地罗马-不列颠人逐渐形成自治政权，但陷入分裂。 遗产 文化：拉丁语影响、基督教基础、城市与法律传统。 遗迹：哈德良长城、巴斯浴场、伦敦城墙等至今可见。 罗马撤离后，不列颠进入\u0026quot;后罗马时期\u0026quot;，为盎格鲁-撒克逊人的入侵埋下伏笔。\n盎格鲁-撒克逊七国（5-9世纪） 社会结构：\n阶层 职责 国王 军事领袖，依赖亲兵（thegn） 自由农 缴纳粮食税（feorm） 奴隶 战俘或债务奴隶 文化标志：\n《贝奥武甫》（8世纪）：现存最古英语史诗，反映英雄价值观。 林迪斯法恩福音书：彩饰手抄本，代表基督教化艺术成就。 背景：罗马不列颠的结束（5世纪初） 罗马帝国于410年从不列颠撤军，结束近400年统治 当地凯尔特-不列颠人失去保护，面临皮克特人（苏格兰）和斯科特人（爱尔兰）侵扰 传说：不列颠王沃蒂根邀请日耳曼部落（盎格鲁人、撒克逊人、朱特人）协助防御 七国时代（Heptarchy）的形成 约6-8世纪，日耳曼移民建立七大主要王国：\n肯特（Kent）：朱特人建立，第一个基督教化王国（597年） 威塞克斯（Wessex）：撒克逊人建立，后成为统一英格兰的核心 埃塞克斯（Essex）、萨塞克斯（Sussex）：东/南撒克逊人 东盎格利亚（East Anglia）：盎格鲁人建立 麦西亚（Mercia）：中部强国，8世纪称霸 诺森布里亚（Northumbria）：北方联盟，文化中心（林迪斯法恩修道院） 关键发展阶段 基督教化（6-7世纪） 597年：教皇格里高利派奥古斯丁至肯特传教 663年惠特比会议：罗马基督教击败凯尔特基督教成为主流 麦西亚霸权（8世纪） 奥法（Offa, 757-796年）统治时期： 修建\u0026quot;奥法堤\u0026quot;（威尔士边界） 发行银便士，建立早期货币体系 维京入侵（9世纪） 793年：林迪斯法恩修道院遭袭，开启\u0026quot;维京时代\u0026quot; 865年：维京大军占领东盎格利亚、诺森布里亚 878年：威塞克斯的阿尔弗雷德大帝（Alfred the Great）在爱丁顿战役获胜，签订《韦德莫尔和约》，保住英格兰西南部 重要遗产 语言：古英语形成（《贝奥武夫》史诗） 法律：早期法典（如《阿尔弗雷德法典》） 行政区划：郡（Shire）制度雏形 统一基础：威塞克斯王朝后期逐渐统一英格兰 时间线结尾 927年：阿尔弗雷德之孙埃塞尔斯坦（Æthelstan）成为首位\u0026quot;英格兰国王\u0026quot; 1016年：丹麦人克努特大帝建立北海帝国，短暂终结盎格鲁-撒克逊统治 这个时期奠定了英格兰的族群构成、语言文化和政治框架，被视为英国民族国家的起源阶段。如需某一具体领域（如宗教、战争、日常生活）的细节可继续探讨。\n诺曼王朝（1066-1154年） 统治技术：\n封建体系： 国王→男爵（分封土地）→骑士（年服役40天）。 1086年《末日审判书》记录13,418个定居点，精准征税。 建筑威慑：伦敦塔白塔（1078年）兼堡垒与王宫，象征诺曼权威。 王朝奠基：征服者威廉的统治（1066-1087年） 1066年黑斯廷斯战役后，诺曼底公爵威廉击败盎格鲁-撒克逊军队，加冕为英格兰国王（史称威廉一世）。其统治核心举措包括：\n土地再分配：没收英格兰贵族土地，分封给诺曼追随者，建立封建采邑制 《末日审判书》（1086年）：首次全国土地普查，确立王权对资源的绝对控制 建筑遗产：伦敦塔、达勒姆大教堂等罗马式建筑彰显诺曼权威 王权巩固与继承危机 威廉二世（1087-1100年） 强化军事统治，持续征收重税，在狩猎中离奇身亡，疑为弟弟亨利策划。\n亨利一世（1100-1135年）\n颁布《自由宪章》争取支持 建立枢密院制度雏形 王室舰队建设提升海军力量 1120年\u0026quot;白船事件\u0026quot;导致继承人溺亡，引发继承危机 内战动荡：斯蒂芬与玛蒂尔达的争夺（1135-1154年） 亨利一世死后，其外甥斯蒂芬与女儿玛蒂尔达爆发长期内战：\n双方僵局：玛蒂尔达（安茹伯爵夫人）联合法国势力对抗 《温彻斯特条约》（1153年）约定由玛蒂尔达之子亨利继位 战争造成\u0026quot;十九年无政府状态\u0026quot;，地方城堡数量激增至500余座 诺曼遗产 行政体系\n引入诺曼底官僚制度 拉丁语成为官方语言 组建国王法庭（Curia Regis） 社会变迁\n法语成为贵族语言（持续至14世纪） 融合盎格鲁-撒克逊与诺曼法制传统 骑士制度与封建义务体系确立 文化影响\n罗马式建筑风格盛行 贵族家谱记录开始规范化 促进英格兰与欧洲大陆的文化交流 1154年亨利二世（玛蒂尔达之子）继位，开启金雀花王朝，诺曼时代正式终结，但其建立的行政框架为未来英格兰的中央集权奠定了基础。\n百年战争（1337-1453年） 关键战役对比：\n战役 年份 战术创新 结果 克雷西 1346 英格兰长弓破骑兵 法军阵亡1.5万 阿金库尔 1415 泥地困住法军重甲 亨利五世重占诺曼底 长期影响：议会借战争扩大征税权，法语退出上层用语。\n战争背景 王位继承问题：1328年法国卡佩王朝绝嗣，英王爱德华三世（1327-1377在位）以法王腓力四世外孙身份争夺王位。 领土争端：英格兰在法国保有阿基坦等领地，法王欲收回。 经济因素：佛兰德斯的羊毛贸易利益驱动英格兰参战。 战争第一阶段（1337-1360） 关键战役： 1340年斯勒伊斯海战：英军取得制海权 1346年克雷西战役：英格兰长弓兵大败法国重骑兵 1356年普瓦捷战役：黑太子爱德华俘虏法王约翰二世 《布雷蒂尼和约》（1360）：英格兰获得加莱及法国西南部大片领土 国内发展（1360-1415） 理查二世统治（1377-1399）： 1381年瓦特·泰勒农民起义 1399年被亨利四世废黜，金雀花王朝终结 兰开斯特王朝建立： 亨利四世（1399-1413）巩固王权 镇压珀西家族叛乱（1403年什鲁斯伯里战役） 战争高潮（1415-1429） 亨利五世（1413-1422）： 1415年阿金库尔战役：以少胜多歼灭法国骑士 1420年《特鲁瓦条约》：获法王继承人资格 婴儿国王亨利六世（1422-1461）： 1428年围困奥尔良 1429年圣女贞德解围，扭转战局 战争尾声（1429-1453） 法国反攻： 1435年勃艮第倒戈 1450年福尔米尼战役失利 最终结果： 1453年英军失去除加莱外所有大陆领土 战争开支导致王室财政崩溃 后续影响 直接引发玫瑰战争（1455-1485） 推动英格兰民族意识形成 议会权力在战争征税中增强 补充说明：战争期间英格兰人口因黑死病（1348-1349）减少约三分之一，促进了农奴制瓦解。军事技术方面，长弓战术和早期火器改变了战争形态。\n宗教改革（1530s-1558年） 亨利八世步骤：\n1529年：以凯瑟琳无子为由申请离婚，遭教皇拒绝。 1534年《至尊法案》：英王成教会最高领袖，关闭600座修道院。 文化控制：1538年要求每教堂置英文《圣经》，削弱拉丁语权威。 这个时期的核心是亨利八世主导的英格兰宗教改革，以及其子女统治时期的宗教反复，史称\u0026quot;英格兰宗教改革时期\u0026quot;。整个过程充满政治博弈与血腥镇压，彻底改变了英国国教体系。\n亨利八世时期（1509-1547） 关键事件：\n离婚案触发改革（1527-1533）\n亨利八世因无男性继承人，要求与凯瑟琳离婚遭教皇拒绝 议会通过《上诉限制法案》（1533）禁止向罗马教廷上诉 确立王权至尊（1534）\n《至尊法案》宣布英王为英国教会最高领袖 托马斯·莫尔因拒绝承认被处死（1535） 解散修道院（1536-1541）\n王室没收修道院财产，增强王室财力 引发\u0026quot;求恩巡礼\u0026quot;起义（1536），遭镇压 爱德华六世时期（1547-1553） 改革激进化的新教时期：\n颁布《公祷书》（1549/1552） 制定《四十二条信纲》（1553） 激进新教徒掌权，摧毁天主教圣像 \u0026ldquo;血腥玛丽\u0026quot;时期（1553-1558） 天主教全面复辟：\n玛丽一世继位后：\n废除父亲与弟弟的宗教立法 恢复教皇权威（1554） 宗教迫害：\n约300名新教徒被处死，包括大主教克兰麦 获得\u0026quot;血腥玛丽\u0026quot;称号 政治危机：\n与西班牙腓力二世联姻引发民众不满 失去加莱港（1558），英国在欧洲大陆最后据点 改革特点 自上而下的改革，政治动机大于宗教虔诚 形成独特的英国国教会（安立甘宗） 埋下了此后百年宗教冲突的伏笔 通过这段历史可以看到，英国的宗教改革本质上是一场由王室主导、议会支持的政治革命，为新教在英国的传播奠定了基础，也为伊丽莎白时代的宗教和解创造了条件。\n工业革命（1760-1840年） 技术创新链：\n纺织业： 1733飞梭（凯伊）→1764珍妮纺纱机（哈格里夫斯）→1785水力织布机。 能源： 1712纽科门蒸汽机→1776瓦特改良版（效提率升5倍）。 社会代价：曼彻斯特工人1819年平均寿命仅17岁，催生《工厂法》（1833）。\n二战与战后（1939-1950s） 关键数据：\n闪电战损失：1940-1941年伦敦遭7.6万吨炸弹，4.3万平民死。 福利国家：1942年《贝弗里奇报告》奠基全民医保（NHS成立于1948）。 帝国解体速度：1947-1965年间，12个主要殖民地独立。 脱欧背景（2016-2020年） 核心矛盾：\n移民问题：欧盟东扩后英国净移民数从2004年24万升至2015年33万。 主权争议：欧洲法院对英国司法干预案件1973-2015年累计143起。 经济影响：2021年对欧贸易额同比下降15.7%，金融业岗位外流1.2万。\n","date":"2022-03-06T00:00:00Z","image":"//localhost:1313/p/history-england-a/coverb_hu_15516e5b362087f6.png","permalink":"//localhost:1313/p/history-england-a/","title":"英国历史简介1"}]